import{_ as a,c as u,a as o,b as e,d as c,f as i,r as l,o as g,e as s}from"./app-C0zayjsd.js";const p={},h={class:"table-of-contents"};function f(v,t){const n=l("Header"),r=l("router-link"),d=l("Footer");return g(),u("div",null,[o(n),e("nav",h,[e("ul",null,[e("li",null,[o(r,{to:"#노드-압박-축출-node-pressure-eviction"},{default:i(()=>t[0]||(t[0]=[s("노드-압박 축출(Node-pressure Eviction)")])),_:1}),e("ul",null,[e("li",null,[o(r,{to:"#의사결정의-입력값-축출-신호-임계값"},{default:i(()=>t[1]||(t[1]=[s("의사결정의 입력값 - 축출 신호 & 임계값")])),_:1}),e("ul",null,[e("li",null,[o(r,{to:"#축출"},{default:i(()=>t[2]||(t[2]=[s("축출")])),_:1})])])]),e("li",null,[o(r,{to:"#_1-요청-초과-여부로-1차-후보군을-가른다"},{default:i(()=>t[3]||(t[3]=[s("1) 요청 초과 여부로 1차 후보군을 가른다")])),_:1})]),e("li",null,[o(r,{to:"#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터"},{default:i(()=>t[4]||(t[4]=[s("2) 같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터")])),_:1})]),e("li",null,[o(r,{to:"#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터"},{default:i(()=>t[5]||(t[5]=[s("3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터")])),_:1}),e("ul",null,[e("li",null,[o(r,{to:"#추가-메모"},{default:i(()=>t[6]||(t[6]=[s("추가 메모")])),_:1})])])])])])])]),t[7]||(t[7]=c('<p>클러스터의 리소스를 효율적으로 운영할수록 자원이 부족할 때 어떻게 행동할지가 중요해진다. 쿠버네티스는 <strong>kubelet의 Node-pressure eviction</strong>으로 노드 안정성을 지키고, **스케줄러의 파드 우선순위/선점(Pod priority &amp; preemption)**으로 리소스가 부족해도 중요한 워크로드를 밀어 넣을 수 있게 한다. 두 메커니즘은 서로 맞물려 동작하므로, 함께 이해해야 운영 품질이 올라갈 수 있다.</p><h1 id="노드-압박-축출-node-pressure-eviction" tabindex="-1"><a class="header-anchor" href="#노드-압박-축출-node-pressure-eviction"><span>노드-압박 축출(Node-pressure Eviction)</span></a></h1><p>노드의 메모리/디스크/PID 등이 임계치에 다다르면, kubelet이 파드를 능동적으로 종료해 자원을 회수하고 노드 정체(Starvation)를 막는다. 이때 축출된 파드의 phase는 Failed로 바뀌며, PDB 나 terminationGracePeriodSeconds 를 존중하지 않을 수 있다.</p><h2 id="의사결정의-입력값-축출-신호-임계값" tabindex="-1"><a class="header-anchor" href="#의사결정의-입력값-축출-신호-임계값"><span>의사결정의 입력값 - <strong>축출 신호 &amp; 임계값</strong></span></a></h2><ul><li>대표 신호 : <code>memory.available</code>, <code>nodefs.available / inodesFree</code>, <code>imagefs.available / inodesFree</code>, (분리 구성 시) <code>containerfs.available / inodesFree</code>, <code>pid.available</code></li><li><strong>하드 임계값 기본값</strong>(일부 OS별 상이) : <code>memory.available&lt;100Mi</code>(리눅스), <code>nodefs.available&lt;10%</code>, <code>imagefs.available&lt;15%</code>, <code>nodefs.inodesFree&lt;5%</code>, <code>imagefs.inodesFree&lt;5%</code></li><li><strong>소프트 임계값</strong>은 <strong>grace period</strong>와 함께 지정하며, <code>eviction-soft</code>, <code>eviction-soft-grace-period</code>, <code>eviction-max-pod-grace-period</code>로 제어</li><li>kubelet은 housekeeping-interval에 설정된 시간 간격(기본값: 10s)마다 축출 임계값을 확인한다. 노드 컨디션 토글 튐 방지는 <code>eviction-pressure-transition-period</code>(기본 <code>5m</code>)</li></ul><blockquote><p><strong>PDB</strong></p></blockquote><p>먼저 하는 일: 노드 레벨 회수 → 그래도 안 되면 파드 축출</p><p>디스크 압박 시: 죽은 파드/컨테이너 GC → 사용하지 않는 이미지 삭제 순으로 정리(파일시스템 구성이 nodefs / imagefs / containerfs냐에 따라 순서가 달라짐)</p><h3 id="축출" tabindex="-1"><a class="header-anchor" href="#축출"><span>축출</span></a></h3><ul><li>Burstable 내에서는 요청(request)을 얼마나 초과해서 쓰는지가 큰 파드부터 우선 퇴출됩니다. (usage − request가 큰 순)</li><li>Guaranteed는 가장 마지막에 퇴출 대상이지만, 노드가 심하게 부족하면 결국 퇴출될 수도 있습니다.</li><li>**컨테이너 한도 초과(OOMKilled)**는 별개입니다. 컨테이너가 자신의 limit을 넘으면 QoS와 무관하게 즉시 OOMKilled 됩니다.</li><li>PriorityClass가 설정돼 있으면, 우선 낮은 우선순위의 파드가 먼저 고려되고, 같은 우선순위끼리일 때 QoS 순서가 적용됩니다.</li></ul><p>좋아요. kubelet이 <strong>메모리 압박(eviction)</strong> 때 파드 축출 대상을 고를 때, 보통 아래 **우선 기준(순서)**로 판단합니다:</p><ol><li>“요청(request)을 초과해서 쓰는가?”</li><li>“파드 우선순위(PriorityClass)는 낮은가?”</li><li>“요청 대비 초과 사용량(usage − request)은 큰가?”</li></ol><p>각 단계마다 <strong>작동 예시</strong>를 들어볼게요. (단위는 메모리)</p><hr><h2 id="_1-요청-초과-여부로-1차-후보군을-가른다" tabindex="-1"><a class="header-anchor" href="#_1-요청-초과-여부로-1차-후보군을-가른다"><span>1) 요청 초과 여부로 1차 후보군을 가른다</span></a></h2><p>노드 용량: <strong>1 GiB</strong></p><table><thead><tr><th>Pod</th><th>QoS</th><th>request</th><th>사용량(usage)</th><th>비고</th></tr></thead><tbody><tr><td>A</td><td>Burstable</td><td>200Mi</td><td>150Mi</td><td><strong>요청 이하</strong></td></tr><tr><td>B</td><td>Burstable</td><td>300Mi</td><td>700Mi</td><td><strong>요청 초과 (+400Mi)</strong></td></tr><tr><td>C</td><td>BestEffort</td><td>0</td><td>80Mi</td><td><strong>요청 초과(+80Mi)</strong> ← request=0이면 사용&gt;0 즉시 초과로 간주</td></tr></tbody></table><ul><li>메모리 압박이 오면 kubelet은 **요청을 넘겨 쓰는 파드(B, C)**를 먼저 후보로 묶습니다.</li><li>요청 이하로 쓰는 A는 <strong>후순위</strong>(보통 마지막까지 남음).</li></ul><hr><h2 id="_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터" tabindex="-1"><a class="header-anchor" href="#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터"><span>2) 같은 “요청 초과” 그룹 안에서는 <strong>PriorityClass</strong>가 낮은 것부터</span></a></h2><p>위 표에서 B와 C가 후보라고 가정하고, 우선순위를 이렇게 둡니다:</p><table><thead><tr><th>Pod</th><th>PriorityClass</th><th>설명</th></tr></thead><tbody><tr><td>B</td><td>1000</td><td>일반 업무 파드</td></tr><tr><td>C</td><td>0</td><td>우선순위 미설정(기본)</td></tr></tbody></table><ul><li>두 파드 모두 “요청 초과”라면, **우선순위가 더 낮은 C(0)**가 <strong>먼저 축출 후보</strong>가 됩니다.</li><li>만약 C가 더 높은 우선순위(예: 10000)를 갖고, B가 낮다면 <strong>B가 먼저</strong> 나갑니다.</li></ul><blockquote><p>요약: 같은 그룹(요청 초과) 안에서는 <strong>낮은 Priority → 먼저 축출</strong>.</p></blockquote><hr><h2 id="_3-우선순위까지-같다면-usage-−-request-가-큰-것부터" tabindex="-1"><a class="header-anchor" href="#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터"><span>3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터</span></a></h2><p>두 파드의 Priority가 같다고 가정:</p><table><thead><tr><th>Pod</th><th>request</th><th>usage</th><th>usage − request</th></tr></thead><tbody><tr><td>B</td><td>300Mi</td><td>700Mi</td><td><strong>+400Mi</strong></td></tr><tr><td>C</td><td>0</td><td>80Mi</td><td><strong>+80Mi</strong></td></tr></tbody></table><ul><li>둘 다 요청 초과 + 동일 Priority라면, **초과량이 더 큰 B(+400Mi)**가 <strong>먼저 축출</strong> 후보가 됩니다.</li><li>이 때문에 상황에 따라 **BestEffort(C)**보다 **Burstable(B)**이 먼저 나가는 **‘역전’**이 실제로 발생할 수 있습니다. (BestEffort가 항상 먼저인 건 아님)</li></ul><hr><h3 id="추가-메모" tabindex="-1"><a class="header-anchor" href="#추가-메모"><span>추가 메모</span></a></h3><ul><li><strong>Guaranteed</strong>(request=limit)은 보통 <strong>가장 마지막</strong>에 축출됩니다.</li><li><strong>OS 레벨 OOM Killer</strong>가 개입하는 진짜 OOM 상황에서는 <code>oom_score_adj</code>(QoS/우선순위에 따라 다름)와 실제 사용량이 함께 작용해, <strong>많이 쓰는 컨테이너</strong>가 더 불리합니다.</li><li><strong>CPU 부족</strong>은 파드 축출 사유가 아니라 스로틀링으로 처리되는 점(주로 eviction은 메모리/디스크 압박)도 참고하세요.</li></ul><p><strong>정리:</strong> 우선순위가 낮아도 “요청 이하”이면 <em>덜 위험</em>할 뿐, <strong>상황이 심하면 축출될 수 있습니다.</strong> 진짜 보호가 필요하면 <code>requests≈피크 사용</code>으로 잡아 <strong>Guaranteed QoS</strong>에 가깝게 하고, 필요한 경우 <strong>PriorityClass</strong>와 전용 노드(taints/tolerations)까지 고려하세요.</p>',33)),o(d)])}const m=a(p,[["render",f],["__file","2025-09-05-podeviction.html.vue"]]),_=JSON.parse('{"path":"/posts/infra/2025-09-05-podeviction.html","title":"쿠버네티스에서 리소스 경합에 의한 Eviction 과 oom_killer 차이","lang":"en-US","frontmatter":{"title":"쿠버네티스에서 리소스 경합에 의한 Eviction 과 oom_killer 차이","date":"2025-09-05T00:00:00.000Z","tags":["kubenetes","eviction","oom_killer"],"description":"두 파드 간에 메모리 등 리소스가 경합할 때 어떤 파드가 어떻게 꺼지고 축출되는지 알아보자"},"headers":[{"level":1,"title":"노드-압박 축출(Node-pressure Eviction)","slug":"노드-압박-축출-node-pressure-eviction","link":"#노드-압박-축출-node-pressure-eviction","children":[{"level":2,"title":"의사결정의 입력값 - 축출 신호 & 임계값","slug":"의사결정의-입력값-축출-신호-임계값","link":"#의사결정의-입력값-축출-신호-임계값","children":[{"level":3,"title":"축출","slug":"축출","link":"#축출","children":[]}]},{"level":2,"title":"1) 요청 초과 여부로 1차 후보군을 가른다","slug":"_1-요청-초과-여부로-1차-후보군을-가른다","link":"#_1-요청-초과-여부로-1차-후보군을-가른다","children":[]},{"level":2,"title":"2) 같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터","slug":"_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터","link":"#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터","children":[]},{"level":2,"title":"3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터","slug":"_3-우선순위까지-같다면-usage-−-request-가-큰-것부터","link":"#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터","children":[{"level":3,"title":"추가 메모","slug":"추가-메모","link":"#추가-메모","children":[]}]}]}],"git":{},"filePathRelative":"_posts/infra/2025-09-05-podeviction.md"}');export{m as comp,_ as data};
