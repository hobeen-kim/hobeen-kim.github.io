import{_ as d,c as p,a as s,b as o,d as c,f as n,r as a,o as u,e as t}from"./app-pgZPx9dX.js";const g={},m={class:"table-of-contents"};function v(k,e){const i=a("Header"),l=a("router-link"),r=a("Footer");return u(),p("div",null,[s(i),o("nav",m,[o("ul",null,[o("li",null,[s(l,{to:"#_1-문제-상황"},{default:n(()=>e[0]||(e[0]=[t("1. 문제 상황")])),_:1}),o("ul",null,[o("li",null,[s(l,{to:"#_1-2-b-tree-인덱스의-한계"},{default:n(()=>e[1]||(e[1]=[t("1.2 B-tree 인덱스의 한계")])),_:1})])])]),o("li",null,[s(l,{to:"#_2-문제-해결"},{default:n(()=>e[2]||(e[2]=[t("2. 문제 해결")])),_:1}),o("ul",null,[o("li",null,[s(l,{to:"#_2-1-trigram-tri-gram-개념"},{default:n(()=>e[3]||(e[3]=[t("2.1 Trigram(tri-gram) 개념")])),_:1})]),o("li",null,[s(l,{to:"#_2-2-postgresql에서의-pg-trgm-확장"},{default:n(()=>e[4]||(e[4]=[t("2.2 PostgreSQL에서의 pg_trgm 확장")])),_:1})]),o("li",null,[s(l,{to:"#_2-3-동작-원리"},{default:n(()=>e[5]||(e[5]=[t("2.3 동작 원리")])),_:1})]),o("li",null,[s(l,{to:"#_2-4-특징"},{default:n(()=>e[6]||(e[6]=[t("2.4 특징")])),_:1})])])]),o("li",null,[s(l,{to:"#_3-해결-후-실행-계획-확인"},{default:n(()=>e[7]||(e[7]=[t("3. 해결 후 실행 계획 확인")])),_:1})]),o("li",null,[s(l,{to:"#_4-추가-개념-gin-인덱스"},{default:n(()=>e[8]||(e[8]=[t("4. 추가 개념: gin 인덱스")])),_:1}),o("ul",null,[o("li",null,[s(l,{to:"#_4-1-기본-개념"},{default:n(()=>e[9]||(e[9]=[t("4.1 기본 개념")])),_:1})]),o("li",null,[s(l,{to:"#_4-2-인덱스-구조"},{default:n(()=>e[10]||(e[10]=[t("4.2 인덱스 구조")])),_:1})]),o("li",null,[s(l,{to:"#_4-3-쓰기-insert-update-시-동작"},{default:n(()=>e[11]||(e[11]=[t("4.3 쓰기(INSERT/UPDATE) 시 동작")])),_:1})]),o("li",null,[s(l,{to:"#_4-4-읽기-select-시-동작"},{default:n(()=>e[12]||(e[12]=[t("4.4 읽기(SELECT) 시 동작")])),_:1})]),o("li",null,[s(l,{to:"#_5-예시-like-good"},{default:n(()=>e[13]||(e[13]=[t("5. 예시: LIKE '%good%'")])),_:1})]),o("li",null,[s(l,{to:"#_6-장단점"},{default:n(()=>e[14]||(e[14]=[t("6. 장단점")])),_:1})])])])])]),e[15]||(e[15]=c(`<blockquote><p>예제 데이터는 <a href="https://www.kaggle.com/datasets/bharadwaj6/kindle-reviews" target="_blank" rel="noopener noreferrer">해당 사이트</a>의 리뷰 데이터를 활용했다. (총 982618개)</p></blockquote><h1 id="_1-문제-상황" tabindex="-1"><a class="header-anchor" href="#_1-문제-상황"><span>1. 문제 상황</span></a></h1><p>review 테이블에서 review_text 로 검색하는 쿼리는 다음과 같다. 이때 대소문자 구분없이 검색하기 위해 <code>lower()</code> 를 사용한다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> review</span>
<span class="line"><span class="token keyword">where</span> lower<span class="token punctuation">(</span>reviewtext<span class="token punctuation">)</span> <span class="token operator">like</span> <span class="token string">&#39;%good%&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>아무런 인덱스나 설정이 없다면 full scan 을 하게 된다. 이 쿼리의 실행계획은 아래와 같다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Gather  (cost=1000.00..83362.62 rows=7863 width=585)</span>
<span class="line">  Workers Planned: 2</span>
<span class="line">  -&gt;  Parallel Seq Scan on review  (cost=0.00..81576.32 rows=3276 width=585)</span>
<span class="line">        Filter: (lower(reviewtext) ~~ &#39;%good%&#39;::text)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Gather</code> 노드는 여러 워커 프로세스에서 처리한 결과를 모아주는 역할을 한다.</li><li><code>Workers Planned: 2</code> → 워커 2개를 띄워서 데이터를 병렬로 스캔한다.</li><li><code>Parallel Seq Scan on review</code> : 인덱스를 쓰지 않고 테이블 전체를 순차적으로 읽다. Parallel Seq Scan 은 테이블을 여러 프로세스가 나눠서 읽으므로 순차 스캔보다 빠를 수 있다.</li><li><code>Filter: (lower(reviewtext) ~~ &#39;%good%&#39;::text)</code> : ~~는 LIKE의 내부 연산자다.</li></ul><h2 id="_1-2-b-tree-인덱스의-한계" tabindex="-1"><a class="header-anchor" href="#_1-2-b-tree-인덱스의-한계"><span>1.2 B-tree 인덱스의 한계</span></a></h2><p><u>여기서 review_text 에 인덱스를 걸어보고 실행계획을 비교해보자.</u></p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">index</span> idx_reviewtext <span class="token keyword">on</span> review <span class="token punctuation">(</span>reviewtext<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>이 때 <code>[54000] ERROR: index row requires 10728 bytes, maximum size is 8191 Where: parallel worker</code> 라는 에러가 나온다. 이는 PostgreSQL의 B-tree 인덱스 한계때문이다.</p><ul><li>Postgres의 일반 B-tree 인덱스는 한 row의 인덱스 엔트리가 <strong>최대 8191바이트(약 8KB)</strong> 를 초과할 수 없다.</li><li><code>reviewtext</code> 컬럼이 긴 텍스트를 포함하고 있을 경우, 그대로 인덱스를 만들면 특정 row에서 이 제한을 초과하여 인덱스 생성에 실패하게 된다.</li></ul><p>만약 B-tree 인덱스가 만들어진다고 해도 <strong><code>%good%</code> 이나<code> %good</code> 검색에는 활용될 수 없다.</strong> B-tree 인덱스는 <strong>정렬된 순서</strong>를 유지하기 때문에 <code>WHERE reviewtext LIKE &#39;good%&#39;</code>처럼 <strong>접두어(prefix)</strong> 가 고정된 검색에는 잘 동작한다. 그 이유는 <code>&#39;good&#39;</code>으로 시작하는 값들이 인덱스 상에서 <strong>연속된 구간(range)</strong> 을 이루기 때문이다. (인덱스 탐색 후 필요한 범위만 읽으면 된다.)</p><p>하지만 <code>%</code>가 앞에 붙어 있는 경우 <code>&#39;good&#39;</code>이 문자열 어디에 나올지 전혀 알 수 없다. 즉, <u>인덱스의 정렬 구조를 활용할 수 없어 모든 행을 확인해야 때문에 이 경우는 풀스캔을 피하기 어렵다.</u></p><h1 id="_2-문제-해결" tabindex="-1"><a class="header-anchor" href="#_2-문제-해결"><span>2. 문제 해결</span></a></h1><p>문제를 해결을 위해 <strong>Trigram 인덱스</strong>와 <strong>Full Text Search (FTS)</strong> 를 찾았고 Trigram 인덱스를 사용하기로 결정했다. FTS 는 단어 단위 검색에 최적화되어있기 때문이다.</p><blockquote><p><strong>Trigram 인덱스 (<code>pg_trgm</code>)</strong></p><ul><li>문자열을 3글자 단위로 쪼개서 GIN 인덱스에 저장. <code>%good%</code> 같은 부분 문자열 검색에도 인덱스를 활용할 수 있음.</li></ul><p><strong>Full Text Search (FTS)</strong></p><ul><li>단어 단위 검색에 최적화. <code>%good%</code> 같은 단순 부분검색이 아니라 <code>&quot;good&quot;</code>이라 는 단어를 찾을 때 훨씬 효율적임</li></ul></blockquote><h2 id="_2-1-trigram-tri-gram-개념" tabindex="-1"><a class="header-anchor" href="#_2-1-trigram-tri-gram-개념"><span>2.1 Trigram(tri-gram) 개념</span></a></h2><p><strong>Trigram</strong> 은 문자열을 <strong>3글자 단위</strong>로 쪼갠 조각을 의미한다. 예를 들어 <code>&quot;good&quot;</code>이라는 문자열이 있다면,</p><ul><li>시작과 끝을 구분하기 위해 보통 padding(<code>␣</code>)을 붙여서 분리한다.</li><li><code>&quot; g&quot;</code>, <code>&quot; go&quot;</code>, <code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code>, <code>&quot;od &quot;</code> 이런 식으로 3글자 단위 조각(trigram) 생성한다.</li><li>이렇게 쪼개진 trigrams 집합을 인덱스에 저장한다.</li></ul><h2 id="_2-2-postgresql에서의-pg-trgm-확장" tabindex="-1"><a class="header-anchor" href="#_2-2-postgresql에서의-pg-trgm-확장"><span>2.2 PostgreSQL에서의 <code>pg_trgm</code> 확장</span></a></h2><p>PostgreSQL은 <code>pg_trgm</code> 확장을 통해 trigram 기반 검색을 지원한다. 아래와 같이 설치하고 인덱스를 생성한다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> EXTENSION <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> pg_trgm<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_review_reviewtext_trgm <span class="token keyword">ON</span> review <span class="token keyword">USING</span> gin <span class="token punctuation">(</span>lower<span class="token punctuation">(</span>reviewtext<span class="token punctuation">)</span> gin_trgm_ops<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>GIN</strong>(Generalized Inverted Index)</p><ul><li>각 row의 값들을 <strong>토큰/요소 단위로 분해해서 역색인(inverted index) 구조</strong>로 저장</li><li>&quot;이 값이 들어 있냐?&quot;를 빠르게 판별</li><li>예: 배열에 특정 값이 포함되어 있는지, 문자열에 특정 trigram이 있는지</li></ul></blockquote><h2 id="_2-3-동작-원리" tabindex="-1"><a class="header-anchor" href="#_2-3-동작-원리"><span>2.3 동작 원리</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> review <span class="token keyword">WHERE</span> lower<span class="token punctuation">(</span>reviewtext<span class="token punctuation">)</span> <span class="token operator">LIKE</span> <span class="token string">&#39;%good%&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>실행 과정</p><ol><li>검색어 <code>&quot;good&quot;</code>을 trigram 집합으로 쪼갠다. (<code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code>)</li><li>인덱스에서 <code>&quot;goo&quot;</code> 또는 <code>&quot;ood&quot;</code>를 포함하는 row 후보군을 빠르게 찾는다.</li><li>후보군만 실제 문자열 비교로 최종 결과를 도출한다.</li></ol></li></ul><p>즉, <strong>후보군을 빠르게 줄여주고 나머지 검증만 하기 때문에 성능이 크게 향상</strong>된다.</p><h2 id="_2-4-특징" tabindex="-1"><a class="header-anchor" href="#_2-4-특징"><span>2.4 특징</span></a></h2><p><strong>장점</strong></p><ul><li><p><strong>부분 문자열 검색 지원</strong></p><ul><li><code>%good%</code>, <code>%oo%</code>, <code>o%</code> 같은 검색에도 인덱스 활용 가능.</li></ul></li><li><p><strong>유사도 검색 지원</strong> : 철자 오류나 오타 검색에 유용</p><ul><li><code>similarity()</code> 함수와 결합하면 <code>&quot;god&quot;</code> ≈ <code>&quot;good&quot;</code> 같은 fuzzy matching 이 가능하다.</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">SELECT * FROM review </span>
<span class="line">WHERE similarity(reviewtext, &#39;good&#39;) &gt; 0.3;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>단점</strong></p><ul><li>문자열을 trigram으로 쪼개서 저장하므로 인덱스가 커서 저장공간이 많이 든다.</li><li>문자열 변경 시 trigram 인덱스도 갱신해야 하므로 write 부하가 늘어나고 Insert/Update 성능이 저하된다.</li><li><u>정확히 prefix search (<code>good%</code>)만 필요하다면 B-tree 인덱스가 더 효율적이다.</u></li></ul><h1 id="_3-해결-후-실행-계획-확인" tabindex="-1"><a class="header-anchor" href="#_3-해결-후-실행-계획-확인"><span>3. 해결 후 실행 계획 확인</span></a></h1><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_review_reviewtext_trgm <span class="token keyword">ON</span> review <span class="token keyword">USING</span> gin <span class="token punctuation">(</span>lower<span class="token punctuation">(</span>reviewtext<span class="token punctuation">)</span> gin_trgm_ops<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>해당 인덱스를 만들고 실행계획을 확인한다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">explain</span></span>
<span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> review</span>
<span class="line"><span class="token keyword">where</span> lower<span class="token punctuation">(</span>reviewtext<span class="token punctuation">)</span> <span class="token operator">like</span> <span class="token string">&#39;%good%&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>아래와 같이 나온다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Bitmap Heap Scan on review  (cost=87.80..23038.73 rows=7861 width=585)</span>
<span class="line">  Recheck Cond: (lower(reviewtext) ~~ &#39;%good%&#39;::text)</span>
<span class="line">  -&gt;  Bitmap Index Scan on idx_review_reviewtext_trgm  (cost=0.00..85.83 rows=7861 width=0)</span>
<span class="line">        Index Cond: (lower(reviewtext) ~~ &#39;%good%&#39;::text)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><code>Bitmap Index Scan on idx_review_reviewtext_trgm</code></li></ol><ul><li><code>lower(reviewtext) LIKE &#39;%good%&#39;</code> 로 탐색</li><li><code>idx_review_reviewtext_trgm</code> 인덱스로 조건을 만족할 가능성이 있는 row들의 위치(rowid = TID)를 비트맵 형태로 생성한다.</li><li>인덱스만 탐색하기 때문에 비용이 매우 저렴함</li></ul><ol start="2"><li><code>Bitmap Heap Scan on review</code><ul><li>인덱스에서 가져온 비트맵(rowid 집합)을 기반으로 실제 테이블(Heap)에서 데이터를 읽는다.</li><li><code>Recheck Cond</code><ul><li>GIN 인덱스는 후보군을 빠르게 좁히지만 <strong>정확히 매칭되는지는 다시 확인이 필요</strong>하다.</li><li>즉, 후보 row를 실제 데이터에서 다시 확인해서 <code>&#39;good&#39;</code>이 정말 들어있는지 체크한다. 이 과정을 <strong>recheck</strong>라고 부른다.</li></ul></li></ul></li></ol><p>실행 계획은 다음과 같은 흐름이다.</p><ol><li><code>pg_trgm</code> 인덱스를 활용해 &quot;good&quot;이 포함될 가능성이 있는 row 후보를 모음 (<code>Bitmap Index Scan</code>)</li><li>후보 row들을 테이블에서 읽고 실제 조건 재검증 (<code>Bitmap Heap Scan</code>)</li><li>최종적으로 매칭되는 row 반환</li></ol><h1 id="_4-추가-개념-gin-인덱스" tabindex="-1"><a class="header-anchor" href="#_4-추가-개념-gin-인덱스"><span>4. 추가 개념: gin 인덱스</span></a></h1><h2 id="_4-1-기본-개념" tabindex="-1"><a class="header-anchor" href="#_4-1-기본-개념"><span>4.1 기본 개념</span></a></h2><ul><li><strong>GIN (Generalized Inverted Index)</strong> 는 말 그대로 <strong>역색인(inverted index)</strong> 이다.</li><li>RDBMS에서 보통 인덱스(B-tree)는 <code>값 → row 위치</code> 구조인데,</li><li><strong>GIN은 <code>토큰(요소) → row 목록</code> 구조</strong>로 저장한다.</li></ul><p>즉,</p><ul><li>B-tree: <code>&quot;홍길동&quot;</code> → rowid=123</li><li>GIN: <code>&quot;홍&quot;</code>, <code>&quot;길&quot;</code>, <code>&quot;동&quot;</code> 각각 → [rowid=123, rowid=456, …]</li></ul><h2 id="_4-2-인덱스-구조" tabindex="-1"><a class="header-anchor" href="#_4-2-인덱스-구조"><span>4.2 인덱스 구조</span></a></h2><p>GIN 인덱스는 크게 두 계층으로 나뉜다.</p><ul><li><strong>Entry Tree</strong><ul><li>인덱스의 &quot;키&quot;(= 토큰, trigram, 단어 등)를 관리하는 B-tree 구조</li><li>예: <code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code>, <code>&quot;app&quot;</code> 같은 trigram 키</li></ul></li><li><strong>Posting List / Posting Tree</strong><ul><li>해당 키를 가진 row들의 목록(row TID)을 저장</li><li>row가 적으면 메모리에 바로 올릴 수 있는 <strong>posting list</strong> 형태</li><li>row가 많아지면 별도의 B-tree인 <strong>posting tree</strong>로 분리 저장</li></ul></li></ul><h2 id="_4-3-쓰기-insert-update-시-동작" tabindex="-1"><a class="header-anchor" href="#_4-3-쓰기-insert-update-시-동작"><span>4.3 쓰기(INSERT/UPDATE) 시 동작</span></a></h2><ol><li>새 row 삽입하면 해당 컬럼 값이 토큰화된다. <ul><li>예: <code>&quot;good&quot;</code> → <code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code></li></ul></li><li>각각의 토큰을 <strong>Entry Tree</strong>에서 찾아 위치를 확인한다.</li><li>해당 키에 rowid를 <strong>posting list</strong>에 추가한다.</li><li>posting list가 너무 커지면 → posting tree로 분리한다.</li></ol><p>이 때문에 GIN은 <strong>쓰기 비용이 크다</strong> (토큰 분해 + 여러 곳에 rowid 삽입)</p><h2 id="_4-4-읽기-select-시-동작" tabindex="-1"><a class="header-anchor" href="#_4-4-읽기-select-시-동작"><span>4.4 읽기(SELECT) 시 동작</span></a></h2><ol><li>쿼리 조건을 토큰으로 분해 <ul><li>예: <code>LIKE &#39;%good%&#39;</code> → <code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code></li><li>FTS <code>&quot;app &amp; name&quot;</code> → <code>&quot;app&quot;</code>, <code>&quot;name&quot;</code></li></ul></li><li>Entry Tree에서 해당 토큰을 찾아 posting list/tree 를 얻는다.</li><li>교집합/합집합 연산으로 후보 rowid 집합을 생성 <ul><li><code>&quot;goo&quot;</code>와 <code>&quot;ood&quot;</code> 둘 다 있어야 함 → 교집합</li></ul></li><li>후보 rowid에 대해 실제 데이터 확인( recheck ) → 최종 결과 반환</li></ol><p>이 구조 덕분에 <strong>부분 검색/포함 검색</strong>이 빠르다.</p><h2 id="_5-예시-like-good" tabindex="-1"><a class="header-anchor" href="#_5-예시-like-good"><span>5. 예시: LIKE &#39;%good%&#39;</span></a></h2><ol><li><code>&quot;good&quot;</code> → <code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code></li><li>Entry Tree에서 <code>&quot;goo&quot;</code>, <code>&quot;ood&quot;</code> 키를 찾음</li><li>각 키가 가진 posting list에서 rowid 모음 <ul><li><code>&quot;goo&quot;</code> → [1, 5, 8]</li><li><code>&quot;ood&quot;</code> → [5, 8, 12]</li></ul></li><li>교집합 → [5, 8]</li><li>row 5, 8에서 실제 문자열 비교 후 최종 결과 확정</li></ol><h2 id="_6-장단점" tabindex="-1"><a class="header-anchor" href="#_6-장단점"><span>6. 장단점</span></a></h2><ul><li><p><strong>장점</strong></p><ul><li>부분 문자열 검색, 배열 포함, JSONB 키 검색, Full Text Search에 강력</li><li>후보군을 줄이는 데 최적화 → 큰 테이블에서 효과 극대화</li></ul></li><li><p><strong>단점</strong></p><ul><li>인덱스 크기가 큼 (토큰 단위로 쪼개 저장)</li><li>쓰기 성능이 느림 (row 추가 시 많은 토큰 업데이트 필요)</li><li>항상 recheck 과정이 필요 → 100% 인덱스만으로 끝나지 않음</li></ul></li><li><p>읽기는 빠르지만, 쓰기는 무겁고 인덱스 크기도 크다</p></li><li><p>따라서 보통 <strong>읽기 위주 workload</strong> (검색, 로그 분석, 텍스트 검색 등)에 적합하다.</p></li></ul>`,62)),s(r)])}const w=d(g,[["render",v],["__file","2025-09-30-likesearch.html.vue"]]),q=JSON.parse(`{"path":"/posts/database/2025-09-30-likesearch.html","title":"실행 계획으로 확인하는 Like 검색 최적화","lang":"en-US","frontmatter":{"title":"실행 계획으로 확인하는 Like 검색 최적화","date":"2025-09-30T00:00:00.000Z","tags":["postgres","like","pg_trgm"],"description":"Like 검색 쿼리를 개선하기 위한 인덱싱 작업입니다."},"headers":[{"level":1,"title":"1. 문제 상황","slug":"_1-문제-상황","link":"#_1-문제-상황","children":[{"level":2,"title":"1.2 B-tree 인덱스의 한계","slug":"_1-2-b-tree-인덱스의-한계","link":"#_1-2-b-tree-인덱스의-한계","children":[]}]},{"level":1,"title":"2. 문제 해결","slug":"_2-문제-해결","link":"#_2-문제-해결","children":[{"level":2,"title":"2.1 Trigram(tri-gram) 개념","slug":"_2-1-trigram-tri-gram-개념","link":"#_2-1-trigram-tri-gram-개념","children":[]},{"level":2,"title":"2.2 PostgreSQL에서의 pg_trgm 확장","slug":"_2-2-postgresql에서의-pg-trgm-확장","link":"#_2-2-postgresql에서의-pg-trgm-확장","children":[]},{"level":2,"title":"2.3 동작 원리","slug":"_2-3-동작-원리","link":"#_2-3-동작-원리","children":[]},{"level":2,"title":"2.4 특징","slug":"_2-4-특징","link":"#_2-4-특징","children":[]}]},{"level":1,"title":"3. 해결 후 실행 계획 확인","slug":"_3-해결-후-실행-계획-확인","link":"#_3-해결-후-실행-계획-확인","children":[]},{"level":1,"title":"4. 추가 개념: gin 인덱스","slug":"_4-추가-개념-gin-인덱스","link":"#_4-추가-개념-gin-인덱스","children":[{"level":2,"title":"4.1 기본 개념","slug":"_4-1-기본-개념","link":"#_4-1-기본-개념","children":[]},{"level":2,"title":"4.2 인덱스 구조","slug":"_4-2-인덱스-구조","link":"#_4-2-인덱스-구조","children":[]},{"level":2,"title":"4.3 쓰기(INSERT/UPDATE) 시 동작","slug":"_4-3-쓰기-insert-update-시-동작","link":"#_4-3-쓰기-insert-update-시-동작","children":[]},{"level":2,"title":"4.4 읽기(SELECT) 시 동작","slug":"_4-4-읽기-select-시-동작","link":"#_4-4-읽기-select-시-동작","children":[]},{"level":2,"title":"5. 예시: LIKE '%good%'","slug":"_5-예시-like-good","link":"#_5-예시-like-good","children":[]},{"level":2,"title":"6. 장단점","slug":"_6-장단점","link":"#_6-장단점","children":[]}]}],"git":{},"filePathRelative":"_posts/database/2025-09-30-likesearch.md"}`);export{w as comp,q as data};
