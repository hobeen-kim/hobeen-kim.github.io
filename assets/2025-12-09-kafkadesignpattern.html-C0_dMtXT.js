import{_ as g,c as p,a as r,b as o,d as c,f as n,r as a,o as d,e as s}from"./app-CMaiEY0m.js";const u={},h={class:"table-of-contents"};function m(f,t){const l=a("Header"),e=a("router-link"),i=a("Footer");return d(),p("div",null,[r(l),o("nav",h,[o("ul",null,[o("li",null,[r(e,{to:"#_1-키-당-단일-작성자-single-writer-per-key-패턴"},{default:n(()=>t[0]||(t[0]=[s("1. 키 당 단일 작성자(Single Writer per Key) 패턴")])),_:1})]),o("li",null,[r(e,{to:"#_2-최신-상태를-위한-로그-컴팩션-log-compaction"},{default:n(()=>t[1]||(t[1]=[s("2. 최신 상태를 위한 로그 컴팩션(Log Compaction)")])),_:1})]),o("li",null,[r(e,{to:"#_3-여러-consumer-group을-이용한-fan-out"},{default:n(()=>t[2]||(t[2]=[s("3. 여러 Consumer Group을 이용한 Fan-Out")])),_:1})]),o("li",null,[r(e,{to:"#_4-재시도-retry-토픽-데드-레터-dead-letter-토픽"},{default:n(()=>t[3]||(t[3]=[s("4. 재시도(Retry) 토픽 & 데드 레터(Dead Letter) 토픽")])),_:1})]),o("li",null,[r(e,{to:"#_5-kafka-streams를-이용한-exactly-once-processing-eos"},{default:n(()=>t[4]||(t[4]=[s("5. Kafka Streams를 이용한 Exactly Once Processing(EoS)")])),_:1})]),o("li",null,[r(e,{to:"#_6-avro-schema-registry로-스키마-진화-schema-evolution"},{default:n(()=>t[5]||(t[5]=[s("6. Avro + Schema Registry로 스키마 진화(Schema Evolution)")])),_:1})]),o("li",null,[r(e,{to:"#_7-이벤트-안무-choreography-vs-오케스트레이션-orchestration"},{default:n(()=>t[6]||(t[6]=[s("7. 이벤트 안무(Choreography) vs 오케스트레이션(Orchestration)")])),_:1}),o("ul",null,[o("li",null,[r(e,{to:"#choreography-방식"},{default:n(()=>t[7]||(t[7]=[s("Choreography 방식")])),_:1})]),o("li",null,[r(e,{to:"#orchestration-방식"},{default:n(()=>t[8]||(t[8]=[s("Orchestration 방식")])),_:1})])])]),o("li",null,[r(e,{to:"#자주-나오는-함정-common-gotchas"},{default:n(()=>t[9]||(t[9]=[s("자주 나오는 함정(Common Gotchas)")])),_:1})]),o("li",null,[r(e,{to:"#마무리"},{default:n(()=>t[10]||(t[10]=[s("마무리")])),_:1})])])]),t[11]||(t[11]=c(`<blockquote><p>[!INFO] Medium 글 번역본입니다. <a href="https://codingplainenglish.medium.com/a-senior-engineers-guide-to-kafka-design-patterns-a193fe9ba078" target="_blank" rel="noopener noreferrer">원글</a></p></blockquote><p>Apache Kafka는 현대 이벤트 기반 아키텍처의 <strong>중심 축</strong>이 되었다. 하지만 Kafka를 제대로 사용하는 건 전혀 다른 이야기다. 특히 <strong>대규모 트래픽</strong>을 다룰수록 더 그렇다.</p><p>시니어 엔지니어라면, 단순히 메시지를 보내고(consuming/producing) 받는 수준을 넘어야 한다. <strong>복원력(resilience), 처리량(throughput), 순서 보장(ordering), 장애 복구(failure recovery), 장기 유지보수성</strong>까지 설계해야 한다.</p><p>이 글은 실무에서 실제로 쓰게 될 <strong>Kafka 설계 패턴들</strong>을 다룬다.</p><h1 id="_1-키-당-단일-작성자-single-writer-per-key-패턴" tabindex="-1"><a class="header-anchor" href="#_1-키-당-단일-작성자-single-writer-per-key-패턴"><span>1. 키 당 단일 작성자(Single Writer per Key) 패턴</span></a></h1><p><strong>언제 사용하나:</strong> 사용자, 세션, 특정 엔티티 단위로 <strong>이벤트 순서를 보존해야 할 때</strong>.</p><p><strong>어떻게 동작하나:</strong> Kafka는 <strong>파티션 내부에서만</strong> 순서를 보장한다. 따라서 <strong>같은 키의 이벤트는 항상 같은 파티션으로</strong> 라우팅하고, 해당 토픽에 **오직 하나의 서비스만 쓰기(write)**를 하도록 설계하면, 순서를 지킬 수 있다.</p><p><strong>예시:</strong> 라이드 헤일링(택시 호출) 앱에서 <strong>기사 위치 정보</strong>를 계속 전송하는 경우</p><ul><li>Key = <code>driver_id</code></li><li>Value = <code>{ &quot;lat&quot;: ..., &quot;lng&quot;: ..., &quot;timestamp&quot;: ... }</code></li></ul><p><strong>팁:</strong></p><ul><li>순서가 중요한 데이터는 <code>user_id</code>, <code>account_id</code>, <code>driver_id</code> 같은 값으로 <strong>파티션 키</strong>를 잡아라.</li><li>순서가 중요할 때는 <strong>랜덤 파티셔닝을 절대 쓰지 말 것</strong>.</li></ul><h1 id="_2-최신-상태를-위한-로그-컴팩션-log-compaction" tabindex="-1"><a class="header-anchor" href="#_2-최신-상태를-위한-로그-컴팩션-log-compaction"><span>2. 최신 상태를 위한 로그 컴팩션(Log Compaction)</span></a></h1><p><strong>언제 사용하나:</strong> 특정 엔티티의 **“현재 최신 상태”**를 유지하고 싶을 때.</p><p><strong>어떻게 동작하나:</strong> 로그 컴팩션이 켜진 토픽은 <strong>각 키에 대해 “가장 최근 메시지”만</strong> 유지한다. 이렇게 하면 Kafka 로그만으로도 서비스가 필요로 하는 상태(예: 캐시)를 <strong>다시 재구성</strong>할 수 있다.</p><p><strong>예시:</strong> 사용자 프로필 서비스가 업데이트 이벤트를 발행한다고 하자.</p><ul><li>Key = <code>&quot;user-123&quot;</code></li><li>Value = <code>{ &quot;email&quot;: &quot;new@mail.com&quot; }</code></li></ul><p>늦게 합류한 컨슈머라도 <strong>컴팩션된 로그를 읽기만 하면</strong> 해당 사용자의 <strong>최신 프로필 정보</strong>를 다시 만들어낼 수 있다.</p><p><strong>팁:</strong></p><ul><li>사용자 상태, 설정값(config), feature flag 등 <strong>상태성 데이터</strong>에 적합하다.</li><li>**스냅샷(snapshot)**과 함께 사용하면 복구 속도를 크게 줄일 수 있다.</li></ul><h1 id="_3-여러-consumer-group을-이용한-fan-out" tabindex="-1"><a class="header-anchor" href="#_3-여러-consumer-group을-이용한-fan-out"><span>3. 여러 Consumer Group을 이용한 Fan-Out</span></a></h1><p><strong>언제 사용하나:</strong> 하나의 이벤트를 <strong>여러 다운스트림 시스템이 동시에</strong> 소비해야 할 때.</p><p><strong>어떻게 동작하나:</strong> 각 컨슈머 그룹은 Kafka에서 <strong>독립적인 읽기 오프셋</strong>을 가진다. 즉, <strong>프로듀서는 하나</strong>인데 <strong>읽는 쪽은 여러 그룹</strong>으로 확장 가능하다.</p><p><strong>예시:</strong> 결제 성공 이벤트 하나를 다음에서 모두 사용해야 할 수 있다.</p><ul><li>분석(Analytics) 팀</li><li>이메일 알림 서비스</li><li>부정거래(Fraud) 탐지 시스템</li></ul><p>이들은 각각 <strong>다른 consumer group ID</strong>를 사용해 읽는다.</p><p><strong>팁:</strong></p><ul><li><strong>하나의 그룹 안에 너무 많은 컨슈머</strong>를 넣으면, 파티션을 두고 서로 경쟁하게 된다.</li><li>하지만 <strong>여러 개의 그룹을 만드는 것 자체는 두려워할 필요 없다</strong>. Kafka는 애초에 이를 위해 설계됐다.</li></ul><h1 id="_4-재시도-retry-토픽-데드-레터-dead-letter-토픽" tabindex="-1"><a class="header-anchor" href="#_4-재시도-retry-토픽-데드-레터-dead-letter-토픽"><span>4. 재시도(Retry) 토픽 &amp; 데드 레터(Dead Letter) 토픽</span></a></h1><p><strong>언제 사용하나:</strong><strong>일시적인 오류</strong>나 <strong>복구 불가능한 처리 실패</strong>를 다뤄야 할 때.</p><p><strong>어떻게 동작하나:</strong> 실패한 메시지를 그대로 막거나(crash) 블로킹하기보다는, 다음과 같이 보낼 수 있다.</p><ul><li><strong>Retry 토픽</strong>: 짧은 지연 후 <strong>재시도</strong>하기 위한 토픽</li><li><strong>Dead-letter 토픽(DLT)</strong>: 더 이상 복구가 어렵다고 판단되는 메시지를 보내고, <strong>알림/모니터링</strong>을 위한 용도</li></ul><p><strong>예시 플로우:</strong></p><p><code>main-topic</code> → <code>processing-service</code> → 실패 시 <code>retry-topic</code>                   ↓                  3번 재시도 후에도 실패 → <code>dead-letter-topic</code></p><p><strong>팁:</strong></p><ul><li>DLT에 보낼 때는 **실패 사유(reason)**를 꼭 함께 담아라.</li><li>DLT는 <strong>반드시 모니터링</strong>해야 한다. &quot;조용히 쌓이게&quot; 놔두면 언젠가 폭발한다.</li></ul><h1 id="_5-kafka-streams를-이용한-exactly-once-processing-eos" tabindex="-1"><a class="header-anchor" href="#_5-kafka-streams를-이용한-exactly-once-processing-eos"><span>5. Kafka Streams를 이용한 Exactly Once Processing(EoS)</span></a></h1><p><strong>언제 사용하나:</strong> 이벤트를 <strong>정확히 한 번(exactly once)</strong> 처리해야 할 때 (최소 한 번(at least once)도, 혹시 한 번 maybe once도 아님).</p><p><strong>어떻게 동작하나:</strong> Kafka Streams는 다음을 통해 EOS를 지원한다.</p><ul><li><strong>멱등(idempotent) 프로듀서</strong></li><li>Kafka와 DB 모두에 대해 <strong>트랜잭셔널 쓰기</strong>를 수행</li></ul><p><strong>예시:</strong> 은행 계좌 간 이체 스트림을 처리하는 경우, 한쪽 계좌에서 출금(debit)하고 다른 계좌에 입금(credit)할 때 재시도 때문에 <strong>중복 기록</strong>이 발생하면 절대 안 된다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">builder</span>
<span class="line">    .stream(&quot;debit-events&quot;)</span>
<span class="line">    .transform(() -&gt; new TransactionalProcessor())</span>
<span class="line">    .to(&quot;ledger-entries&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>팁:</strong></p><ul><li>컴팩션 토픽, 멱등성 DB 쓰기와 함께 사용하면 특히 잘 맞는다.</li><li>EoS는 <strong>복잡성을 확실히 끌어올린다</strong>. <strong>정말 필요한 경우에만</strong> 적용해라.</li></ul><h1 id="_6-avro-schema-registry로-스키마-진화-schema-evolution" tabindex="-1"><a class="header-anchor" href="#_6-avro-schema-registry로-스키마-진화-schema-evolution"><span>6. Avro + Schema Registry로 스키마 진화(Schema Evolution)</span></a></h1><p><strong>언제 사용하나:</strong> 메시지 포맷이 <strong>시간이 지나며 계속 바뀌는</strong> 경우 (사실 모든 서비스가 그렇다).</p><p><strong>어떻게 동작하나:</strong> Avro + Confluent Schema Registry를 사용하면 **후방/전방 호환성(backward/forward compatibility)**을 가진 스키마를 정의하고 진화시킬 수 있다.</p><p><strong>예시:</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">record User {</span>
<span class="line">  string user_id;</span>
<span class="line">  string email;</span>
<span class="line">  string phone; // 새로 추가된 optional 필드</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>프로듀서와 컨슈머 모두, 데이터를 <strong>보내거나 받을 때 스키마 기반으로 검증</strong>한다.</p><p><strong>팁:</strong></p><ul><li>스키마 호환성 규칙은 기본적으로 <strong>backward compatibility</strong>를 사용하는 것이 안전하다.</li><li>스키마 변경과 버전 관리는 <strong>문서화</strong>를 철저히 해라.</li></ul><h1 id="_7-이벤트-안무-choreography-vs-오케스트레이션-orchestration" tabindex="-1"><a class="header-anchor" href="#_7-이벤트-안무-choreography-vs-오케스트레이션-orchestration"><span>7. 이벤트 안무(Choreography) vs 오케스트레이션(Orchestration)</span></a></h1><p><strong>언제 사용하나:</strong> 주문 처리 같은 <strong>멀티 서비스 워크플로우</strong>가 있을 때.</p><p><strong>어떻게 동작하나:</strong></p><ul><li><strong>Choreography</strong>: 각 서비스가 이벤트를 구독하고, 그에 <strong>반응</strong>하면서 일련의 흐름이 만들어진다. (느슨한 결합)</li><li><strong>Orchestration</strong>: 중앙 오케스트레이터가 각 서비스를 <strong>호출하고 지시</strong>하면서 플로우를 명시적으로 관리한다. (명시적 제어)</li></ul><p><strong>예시:</strong></p><h3 id="choreography-방식" tabindex="-1"><a class="header-anchor" href="#choreography-방식"><span>Choreography 방식</span></a></h3><ol><li>Order 서비스가 <code>OrderPlaced</code> 이벤트 발행</li><li>Inventory 서비스가 이를 구독 → <code>InventoryReserved</code> 이벤트 발행</li><li>Payment 서비스가 이를 구독 → <code>PaymentCompleted</code> 이벤트 발행</li></ol><h3 id="orchestration-방식" tabindex="-1"><a class="header-anchor" href="#orchestration-방식"><span>Orchestration 방식</span></a></h3><ul><li>Orchestrator 서비스가 순서대로 Inventory, Payment 등을 호출하고 그 결과를 다시 듣고 전체 플로우를 제어한다.</li></ul><p><strong>팁:</strong></p><ul><li><strong>Choreography</strong>: 스케일 아웃은 쉽지만, <strong>버그 추적이 어려워</strong>질 수 있다.</li><li><strong>Orchestration</strong>: 디버깅은 쉬워지지만, <strong>결합도가 높아진다.</strong></li></ul><h1 id="자주-나오는-함정-common-gotchas" tabindex="-1"><a class="header-anchor" href="#자주-나오는-함정-common-gotchas"><span>자주 나오는 함정(Common Gotchas)</span></a></h1><ul><li>파티션 수를 너무 많이 잡으면 <strong>컨슈머 시작 시간</strong>과 <strong>리밸런스</strong>가 느려진다.</li><li><strong>1MB 이상</strong>의 큰 메시지는 다운스트림 시스템을 쉽게 망가뜨린다. 큰 페이로드는 Kafka에 직접 실지 말고, **Blob 스토리지(S3 등)**를 사용해라.</li><li><strong>키가 없는(unkeyed) 메시지</strong>는 순서를 잃는다. <strong>중요한 엔티티에는 항상 키를 넣어라.</strong></li><li>컨슈머에서 처리 시간이 너무 길면 리밸런스를 오래 잡아먹는다. 가능하면 <strong>빠르게, 상태 없는(stateless) 처리</strong>로 설계해라.</li></ul><h1 id="마무리" tabindex="-1"><a class="header-anchor" href="#마무리"><span>마무리</span></a></h1><p>Kafka는 그저 **&quot;파이프&quot;일 뿐이다. **어떻게 설계해서 쓰느냐가 모든 걸 결정한다.</p><p>시니어 엔지니어라면 Kafka는 단순히 <strong>클러스터를 세팅하는 도구</strong>가 아니다. 다음 같은 것들을 설계하는 일에 가깝다.</p><ul><li>안전한 <strong>재시도 플로우</strong></li><li>제대로 된 <strong>메시지 스키마</strong></li><li>망가지지 않는 <strong>이벤트 기반 패턴</strong></li></ul><p>이 패턴들을 활용하면, 트래픽이 몰리는 상황에서도 <strong>신뢰성 있고, 관측 가능하며, 유지보수가 가능한 시스템</strong>을 만들 수 있다.</p><p>그리고 항상 기억하자:</p><blockquote><p><strong>1K TPS에서 잘 돌아간다고 해서, 100K TPS에서도 잘 돌아간다는 보장은 전혀 없다.</strong> 설계가 안 되어 있으면, 규모가 커질수록 반드시 터진다.</p></blockquote>`,71)),r(i)])}const k=g(u,[["render",m],["__file","2025-12-09-kafkadesignpattern.html.vue"]]),y=JSON.parse('{"path":"/posts/kafka/2025-12-09-kafkadesignpattern.html","title":"시니어 엔지니어의 kafka 디자인 패턴","lang":"en-US","frontmatter":{"title":"시니어 엔지니어의 kafka 디자인 패턴","date":"2025-12-09T00:00:00.000Z","tags":["kafka"],"description":"kafka 디자인 패턴 7가지"},"headers":[{"level":1,"title":"1. 키 당 단일 작성자(Single Writer per Key) 패턴","slug":"_1-키-당-단일-작성자-single-writer-per-key-패턴","link":"#_1-키-당-단일-작성자-single-writer-per-key-패턴","children":[]},{"level":1,"title":"2. 최신 상태를 위한 로그 컴팩션(Log Compaction)","slug":"_2-최신-상태를-위한-로그-컴팩션-log-compaction","link":"#_2-최신-상태를-위한-로그-컴팩션-log-compaction","children":[]},{"level":1,"title":"3. 여러 Consumer Group을 이용한 Fan-Out","slug":"_3-여러-consumer-group을-이용한-fan-out","link":"#_3-여러-consumer-group을-이용한-fan-out","children":[]},{"level":1,"title":"4. 재시도(Retry) 토픽 & 데드 레터(Dead Letter) 토픽","slug":"_4-재시도-retry-토픽-데드-레터-dead-letter-토픽","link":"#_4-재시도-retry-토픽-데드-레터-dead-letter-토픽","children":[]},{"level":1,"title":"5. Kafka Streams를 이용한 Exactly Once Processing(EoS)","slug":"_5-kafka-streams를-이용한-exactly-once-processing-eos","link":"#_5-kafka-streams를-이용한-exactly-once-processing-eos","children":[]},{"level":1,"title":"6. Avro + Schema Registry로 스키마 진화(Schema Evolution)","slug":"_6-avro-schema-registry로-스키마-진화-schema-evolution","link":"#_6-avro-schema-registry로-스키마-진화-schema-evolution","children":[]},{"level":1,"title":"7. 이벤트 안무(Choreography) vs 오케스트레이션(Orchestration)","slug":"_7-이벤트-안무-choreography-vs-오케스트레이션-orchestration","link":"#_7-이벤트-안무-choreography-vs-오케스트레이션-orchestration","children":[{"level":3,"title":"Choreography 방식","slug":"choreography-방식","link":"#choreography-방식","children":[]},{"level":3,"title":"Orchestration 방식","slug":"orchestration-방식","link":"#orchestration-방식","children":[]}]},{"level":1,"title":"자주 나오는 함정(Common Gotchas)","slug":"자주-나오는-함정-common-gotchas","link":"#자주-나오는-함정-common-gotchas","children":[]},{"level":1,"title":"마무리","slug":"마무리","link":"#마무리","children":[]}],"git":{},"filePathRelative":"_posts/kafka/2025-12-09-kafkadesignpattern.md"}');export{k as comp,y as data};
