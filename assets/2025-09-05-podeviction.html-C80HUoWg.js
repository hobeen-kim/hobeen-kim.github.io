import{_ as d,c as p,a as o,b as e,d as c,f as s,r as i,o as u,e as r}from"./app-YqI8wmw3.js";const g={},h={class:"table-of-contents"};function b(v,t){const l=i("Header"),n=i("router-link"),a=i("Footer");return u(),p("div",null,[o(l),e("nav",h,[e("ul",null,[e("li",null,[o(n,{to:"#노드-압박-축출-node-pressure-eviction"},{default:s(()=>t[0]||(t[0]=[r("노드-압박 축출(Node-pressure Eviction)")])),_:1}),e("ul",null,[e("li",null,[o(n,{to:"#의사결정의-입력값-축출-신호-임계값"},{default:s(()=>t[1]||(t[1]=[r("의사결정의 입력값 - 축출 신호 & 임계값")])),_:1})]),e("li",null,[o(n,{to:"#축출-순서"},{default:s(()=>t[2]||(t[2]=[r("축출 순서")])),_:1}),e("ul",null,[e("li",null,[o(n,{to:"#축출-예시"},{default:s(()=>t[3]||(t[3]=[r("축출 예시")])),_:1})])])]),e("li",null,[o(n,{to:"#파드-우선순위-priority-와-선점-preemption"},{default:s(()=>t[4]||(t[4]=[r("파드 우선순위(Priority)와 선점(Preemption)")])),_:1}),e("ul",null,[e("li",null,[o(n,{to:"#스케줄-순서와-선점-동작"},{default:s(()=>t[5]||(t[5]=[r("스케줄 순서와 선점 동작")])),_:1})]),e("li",null,[o(n,{to:"#한계와-주의점"},{default:s(()=>t[6]||(t[6]=[r("한계와 주의점")])),_:1})]),e("li",null,[o(n,{to:"#qos와의-관계"},{default:s(()=>t[7]||(t[7]=[r("QoS와의 관계")])),_:1})])])])])]),e("li",null,[o(n,{to:"#ref"},{default:s(()=>t[8]||(t[8]=[r("Ref.")])),_:1})])])]),t[9]||(t[9]=c(`<p>클러스터의 리소스를 효율적으로 운영할수록 자원이 부족할 때 어떻게 행동할지가 중요해진다. 쿠버네티스는 <strong>kubelet의 Node-pressure eviction</strong>으로 노드 안정성을 지키고, **스케줄러의 파드 우선순위/선점(Pod priority &amp; preemption)**으로 리소스가 부족해도 중요한 워크로드를 밀어 넣을 수 있게 한다. 두 메커니즘은 서로 맞물려 동작하므로, 함께 이해해야 운영 품질이 올라갈 수 있다.</p><h1 id="노드-압박-축출-node-pressure-eviction" tabindex="-1"><a class="header-anchor" href="#노드-압박-축출-node-pressure-eviction"><span>노드-압박 축출(Node-pressure Eviction)</span></a></h1><p>노드의 메모리/디스크/PID 등이 임계치에 다다르면, kubelet이 파드를 능동적으로 종료해 자원을 회수하고 노드 정체(Starvation)를 막는다. 이때 축출된 파드의 phase는 Failed로 바뀌며, PDB 나 terminationGracePeriodSeconds 를 존중하지 않을 수 있다.</p><h2 id="의사결정의-입력값-축출-신호-임계값" tabindex="-1"><a class="header-anchor" href="#의사결정의-입력값-축출-신호-임계값"><span>의사결정의 입력값 - <strong>축출 신호 &amp; 임계값</strong></span></a></h2><ul><li>대표 신호 : <code>memory.available</code>, <code>nodefs.available / inodesFree</code>, <code>imagefs.available / inodesFree</code>, (분리 구성 시) <code>containerfs.available / inodesFree</code>, <code>pid.available</code></li><li><strong>하드 임계값 기본값</strong>(일부 OS별 상이) : <code>memory.available&lt;100Mi</code>(리눅스), <code>nodefs.available&lt;10%</code>, <code>imagefs.available&lt;15%</code>, <code>nodefs.inodesFree&lt;5%</code>, <code>imagefs.inodesFree&lt;5%</code></li><li><strong>소프트 임계값</strong>은 <strong>grace period</strong>와 함께 지정하며, <code>eviction-soft</code>, <code>eviction-soft-grace-period</code>, <code>eviction-max-pod-grace-period</code>로 제어</li><li>kubelet은 housekeeping-interval에 설정된 시간 간격(기본값: 10s)마다 축출 임계값을 확인한다. 노드 컨디션 토글 튐 방지는 <code>eviction-pressure-transition-period</code>(기본 <code>5m</code>)</li></ul><blockquote><p><strong>PDB</strong></p><p>PDB는 <strong>Pod Disruption Budget</strong>의 약자로, 쿠버네티스에서 자발적(Voluntary) 중단이 일어날 때, 한 번에 중단될 수 있는 파드 수를 제한해서 <strong>가용성을 최소 보장</strong>하는 정책이다.</p></blockquote><p><strong>먼저 하는 일: 노드 레벨 회수 → 그래도 안 되면 파드 축출</strong></p><p>디스크 압박 시에는 죽은 파드/컨테이너부터 GC 을 진행하고, 사용하지 않는 이미지 삭제 순으로 정리한다.(파일시스템 구성이 nodefs / imagefs / containerfs냐에 따라 순서가 달라짐)</p><h2 id="축출-순서" tabindex="-1"><a class="header-anchor" href="#축출-순서"><span>축출 순서</span></a></h2><p>kubelet은 아래 기준으로 <strong>순위를 매겨 축출</strong>한다.</p><ol><li><strong>요청치(request)를 초과</strong>해서 리소스를 쓰는가</li><li><strong>파드 Priority</strong></li><li><strong>요청 대비 사용량 초과 정도</strong> 정리하면, <strong>요청을 넘겨 쓰는 <code>BestEffort</code>/<code>Burstable</code> → (마지막) <code>Guaranteed</code>/요청 이내 <code>Burstable</code></strong> 순으로, 같은 급에서는 <strong>Priority가 낮을수록 먼저</strong> 나갑니다. QoS 클래스는 <strong>순위 계산의 직접 입력은 아니지만</strong>, 메모리 압박 상황에서 <strong>예상 순서를 가늠하는 지표</strong>가 됩니다. <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/" target="_blank" rel="noopener noreferrer">Kubernetes</a></li></ol><blockquote><p>주의: 시스템 데몬(<code>kubelet</code>, <code>journald</code>)이 예약치를 넘겨 쓰고, 남은 파드가 모두 <code>Guaranteed</code>/요청 이하라 해도 <strong>노드 안정성</strong>을 위해 <strong>Priority가 가장 낮은 파드부터 축출</strong>될 수 있다. 또한 <strong>정적 파드</strong>는 <code>priorityClassName</code>이 아닌 <code>priority</code> 필드를 직접 지정해야 한다.</p></blockquote><h3 id="축출-예시" tabindex="-1"><a class="header-anchor" href="#축출-예시"><span>축출 예시</span></a></h3><ol><li><strong>요청 초과 여부로 1차 후보군을 가른다</strong></li></ol><p>노드 용량: <strong>1 GiB</strong></p><table><thead><tr><th>Pod</th><th>QoS</th><th>request</th><th>사용량(usage)</th><th>비고</th></tr></thead><tbody><tr><td>A</td><td>Burstable</td><td>200Mi</td><td>150Mi</td><td><strong>요청 이하</strong></td></tr><tr><td>B</td><td>Burstable</td><td>300Mi</td><td>700Mi</td><td><strong>요청 초과 (+400Mi)</strong></td></tr><tr><td>C</td><td>BestEffort</td><td>0</td><td>80Mi</td><td><strong>요청 초과(+80Mi)</strong> ← request=0이면 사용&gt;0 즉시 초과로 간주</td></tr></tbody></table><ul><li>메모리 압박이 오면 kubelet은 **요청을 넘겨 쓰는 파드(B, C)**를 먼저 후보로 묶는다.</li><li>요청 이하로 쓰는 A는 <strong>후순위</strong>(보통 마지막까지 남음).</li></ul><ol start="2"><li><strong>같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터</strong></li></ol><p>위 표에서 B와 C가 후보라고 가정하고, 우선순위를 이렇게 두게 된다.</p><table><thead><tr><th>Pod</th><th>PriorityClass</th><th>설명</th></tr></thead><tbody><tr><td>B</td><td>1000</td><td>일반 업무 파드</td></tr><tr><td>C</td><td>0</td><td>우선순위 미설정(기본)</td></tr></tbody></table><ul><li>두 파드 모두 “요청 초과”라면, **우선순위가 더 낮은 C(0)**가 <strong>먼저 축출 후보</strong>가 된다.</li><li>만약 C가 더 높은 우선순위(예: 10000)를 갖고, B가 낮다면 <strong>B가 먼저</strong> 나간다.</li></ul><blockquote><p>요약: 같은 그룹(요청 초과) 안에서는 <strong>낮은 Priority → 먼저 축출</strong>.</p></blockquote><ol start="3"><li><strong>우선순위까지 같다면, (usage − request)가 큰 것부터</strong></li></ol><p>두 파드의 Priority가 같다고 가정</p><table><thead><tr><th>Pod</th><th>request</th><th>usage</th><th>usage − request</th></tr></thead><tbody><tr><td>B</td><td>300Mi</td><td>700Mi</td><td><strong>+400Mi</strong></td></tr><tr><td>C</td><td>0</td><td>80Mi</td><td><strong>+80Mi</strong></td></tr></tbody></table><ul><li>둘 다 요청 초과 + 동일 Priority라면, **초과량이 더 큰 B(+400Mi)**가 <strong>먼저 축출</strong> 후보가 된다.</li><li>이 때문에 상황에 따라 **BestEffort(C)**보다 **Burstable(B)**이 먼저 나가는 **‘역전’**이 실제로 발생할 수 있다. (BestEffort가 항상 먼저인 건 아님)</li></ul><h2 id="파드-우선순위-priority-와-선점-preemption" tabindex="-1"><a class="header-anchor" href="#파드-우선순위-priority-와-선점-preemption"><span>파드 우선순위(Priority)와 선점(Preemption)</span></a></h2><p>리소스가 모자라 <strong>대기 중인 파드</strong>가 생기면, 스케줄러는 **Priority가 더 낮은 파드들을 축출(선점)**해 <strong>대기 중인 고 우선순위 파드</strong>가 들어갈 공간을 만든다. 이를 쓰려면 먼저 <code>PriorityClass</code>를 만들고, 파드에 <code>priorityClassName</code>을 지정하면 된다. 쿠버네티스는 기본으로 <code>system-cluster-critical</code>, <code>system-node-critical</code> 클래스를 제공한다.</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> scheduling.k8s.io/v1</span>
<span class="line"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PriorityClass</span>
<span class="line"><span class="token key atrule">metadata</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">name</span><span class="token punctuation">:</span> high<span class="token punctuation">-</span>priority</span>
<span class="line"><span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token number">1000000</span></span>
<span class="line"><span class="token key atrule">globalDefault</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></span>
<span class="line"><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">&quot;핵심 서비스용&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>선점하지 않는 우선순위</strong><code>preemptionPolicy: Never</code>를 갖는 <strong>Non-preempting PriorityClass</strong>를 쓰면, <strong>큐에서는 우선 배치되지만</strong> 다른 파드를 밀어내지는 않는다. 긴 연산(job) 등에서 유용하다.</p></blockquote><h3 id="스케줄-순서와-선점-동작" tabindex="-1"><a class="header-anchor" href="#스케줄-순서와-선점-동작"><span>스케줄 순서와 선점 동작</span></a></h3><ul><li><strong>대기 큐</strong>는 Priority 높은 파드가 앞서고, 스케줄 요건을 만족하면 먼저 배치한다. 만족 못하면 다음 파드로 넘어간다.</li><li>선점이 트리거되면 스케줄러는 <strong>한 노드에서 낮은 Priority 파드들을 골라 축출</strong>해, 대기 파드가 들어갈 여지를 만든다. 이때 대기 파드의 <code>status.nominatedNodeName</code>이 표시될 수 있으나, 최종 스케줄 노드와 다를 수 있다.</li></ul><h3 id="한계와-주의점" tabindex="-1"><a class="header-anchor" href="#한계와-주의점"><span>한계와 주의점</span></a></h3><ul><li><strong>유예 종료 시간</strong>: 희생 파드는 <strong>graceful termination</strong>을 받고, 그 시간 동안은 자리 확보가 지연된다. 지나치게 길면 선점 효과가 약해진다.</li><li><strong>PDB는 최대한 존중</strong>: 스케줄러는 가능한 PDB를 침해하지 않으려 하지만, 불가피하면 PDB를 어기고서라도 선점할 수 있다.</li><li><strong>크로스 노드 선점 없음</strong>: 어떤 파드의 anti-affinity 때문에 <strong>다른 노드의 파드</strong>를 치워야만 스케줄 가능한 상황이라면, 현행 스케줄러는 그런 교차 노드 선점을 하지 않는다.</li></ul><h3 id="qos와의-관계" tabindex="-1"><a class="header-anchor" href="#qos와의-관계"><span>QoS와의 관계</span></a></h3><p>Priority와 QoS는 직교(orthogonal) 합니다. 선점 시 스케줄러는 QoS를 고려하지 않고 Priority만 보고 희생자를 고르지만, 노드-압박 축출에서는 Priority가 순위에 영향을 주며 QoS는 <strong>예상 지표</strong>로 볼 수 있다.</p>`,36)),o(a),t[10]||(t[10]=e("h1",{id:"ref",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#ref"},[e("span",null,"Ref.")])],-1)),t[11]||(t[11]=e("ul",null,[e("li",null,[e("a",{href:"https://kubernetes.io/ko/docs/concepts/scheduling-eviction/node-pressure-eviction/",target:"_blank",rel:"noopener noreferrer"},"노드-압박 축출")]),e("li",null,[e("a",{href:"https://kubernetes.io/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/",target:"_blank",rel:"noopener noreferrer"},"파드 우선순위(priority)와 선점(preemption)")])],-1))])}const m=d(g,[["render",b],["__file","2025-09-05-podeviction.html.vue"]]),k=JSON.parse('{"path":"/posts/infra/2025-09-05-podeviction.html","title":"쿠버네티스에서 리소스 경합에 의한 Eviction 과 oom_killer 차이","lang":"en-US","frontmatter":{"title":"쿠버네티스에서 리소스 경합에 의한 Eviction 과 oom_killer 차이","date":"2025-09-05T00:00:00.000Z","tags":["kubenetes","eviction","oom_killer"],"description":"두 파드 간에 메모리 등 리소스가 경합할 때 어떤 파드가 어떻게 꺼지고 축출되는지 알아보자"},"headers":[{"level":1,"title":"노드-압박 축출(Node-pressure Eviction)","slug":"노드-압박-축출-node-pressure-eviction","link":"#노드-압박-축출-node-pressure-eviction","children":[{"level":2,"title":"의사결정의 입력값 - 축출 신호 & 임계값","slug":"의사결정의-입력값-축출-신호-임계값","link":"#의사결정의-입력값-축출-신호-임계값","children":[]},{"level":2,"title":"축출 순서","slug":"축출-순서","link":"#축출-순서","children":[{"level":3,"title":"축출 예시","slug":"축출-예시","link":"#축출-예시","children":[]}]},{"level":2,"title":"파드 우선순위(Priority)와 선점(Preemption)","slug":"파드-우선순위-priority-와-선점-preemption","link":"#파드-우선순위-priority-와-선점-preemption","children":[{"level":3,"title":"스케줄 순서와 선점 동작","slug":"스케줄-순서와-선점-동작","link":"#스케줄-순서와-선점-동작","children":[]},{"level":3,"title":"한계와 주의점","slug":"한계와-주의점","link":"#한계와-주의점","children":[]},{"level":3,"title":"QoS와의 관계","slug":"qos와의-관계","link":"#qos와의-관계","children":[]}]}]},{"level":1,"title":"Ref.","slug":"ref","link":"#ref","children":[]}],"git":{},"filePathRelative":"_posts/infra/2025-09-05-podeviction.md"}');export{m as comp,k as data};
