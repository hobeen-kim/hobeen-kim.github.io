---
categories: "CS"
tag: ["자료구조", "list"]
---

<div class="notice--danger">
    <b>'쉽게 배우는 자료구조 with 자바 (문병로)' 내용 중 일부입니다.</b>
</div>

# 리스트

​	리스트란 '줄 세워져 있는 데이터' 또는 '죽 늘어선 데이터'를 의미합니다. 리스트를 관리하기 위한 작업은 다음과 같은 ADT 리스트로 대략 정리할 수 있습니다. 물론 개략적인 내용입니다. 

- i  번째 자리에 원소 x 를 삽입
- i 번째 원소를 삭제
- 원소 x 를 삭제
- i 번째 원소를 알려줌
- 원소 x 가 몇 번째인지 알려줌
- 리스트의 사이즈를 알려줌

​	리스트의 구현하는 방법은 대표적으로 두가지가 있습니다. 배열에 원소들을 쭉 배치하는 방법과 링크를 이용해 원소들을 연결하는 방법입니다. **배열을 이용한 리스트**는 가장 단순한 구현 방법으로 시작위치부터 빈자리 없이 자료를 순서대로 저장하므로 논리적인 순서와 물리적인 순서가 일치합니다. 하지만 충분한 공간을 확보해두어야 한다는 점과 공간 낭비가 있다는 점이 단점입니다. **연결 리스트**는 반대로 삽입, 삭제 연산 시에 논리적인 순서가 변경되어도 물리적인 순서는 변경되지 않습니다. 또한 원소가 추가될 때마다 공간을 할당받아 추가하는 동적 할당 방식으로 배열의 공간 낭비를 피할 수 있습니다.

# 배열 리스트

​	먼저 배열리스트를 구현해보겠습니다. 배열 리스트의 가장 대표적인 클래스는 ArrayList 지만 구현되는 코드가 완전히 일치하지는 않습니다.

- 필드 : item[] (저장 공간), newItems(원소의 개수)
- 메서드 : add(), append(), remove(), removeItem(), get(), set(), indexOf(), len(), isEmpty(), clear()

## add()

```
add(k, x):
	if(numItems >= item.length || k < 0 || k > numItems)
	/* error */
	else
		for i <- numItem-1 downto k
			item[i+1] <- item[i]
        item[k] <- x
        numItems++
```

`item[i+1] <- item[i]` 에서 모든 원소들은 오른쪽으로 한칸씩 밀어냅니다. 이때 제일 오른쪽 원소부터 밀어내야 합니다. 따라서 제일 오래걸리는 삽입은 맨 앞에 원소를 추가할 때 입니다.

## append()

```
append(x):
	if(numItems >= item.length)
	/* error */
	else
		item[numItems++] <- x
```

리스트의 맨 뒤에 원소를 추가하는 알고리즘입니다. add(numitems, x) 로 호출해도 되지만, 리스트 끝에 추가하는 작업은 잦기 때문에 따로 만들어줍니다.

## remove()

```
remove(k):
	if(isEmpty() || k < 0 || k > numItems-1)
	/* error */
	else
		for i <- k to numItems-2
			item[i] <- item[i+1]
        numItems--
```

k 번째 원소를 삭제하는 알고리즘입니다. k 번째 이후 원소들을 모두 좌시프트하면 삭제됩니다.

## removeItem()

```
removeItem(x):
	k <- 0
	while(k < numItems && item[k] ! = x)
		k++
    if(k == numItems) return false
    else
    	remove(k)
    	return true
```

특정 원소 x 를 삭제하는 알고리즘입니다. 삭제하려는 x 의 인덱스를 찾아서 remove() 와 같은 방식으로 삭제합니다.

## get()

```
get(i):
	if(i >= 0 && numItem-1)
		return item[i]
    else
    	return OUT_OF_BOUND
```

배열에서 i 번째 원소를 반환합니다. 범위 밖이라면 OUT_OF_BOUND 를 리턴합니다.

## set()

```
set(i, x):
	if(i >= 0 && i <= numItems-1)
		item[i] <- x
    else
    	/* error */
```

i 번째 원소를 x 로 대체합니다.


## indexOf()

```
indexOf(x):
	i <- 0
	while(i < numItems && item[i] != x)
		i++
    if(i = numItems)
    	return NOT_FOUND
    else
		return i
```

x 가 리스트 몇 번째 원소인지 반환합니다. 첫 번째 요소부터 비교하여 찾아냅니다.

## len(), isEmpty(), clear()

```
len():
	return numItems
	
isEmpty():
	if(numItems = 0)
		return true
    else
    	return false
    	
clear():
	numItems <- 0
```



## ArrayList 구현

**Interface**

​	이제 알고리즘을 구현해보겠습니다. 먼저 인터페이스를 만들고 List 를 구현하겠습니다.

```java
public interface ListInterface<E>{
	public void add(int i, E x);
	public void append(E x);
	public E remove(int i);
	public boolean removeItem(E x);
	public E get(int i);
	public void set(int i, E x);
	public int indexOf(E x);
	public int len();
	public boolean isEmpty();
	public void clear();
}
```

**ArrayList**

```java
package ArrayList;

public class ArrayList<E> implements ListInterface<E>{

    private E item[];
    private int numItems;
    private static final int DEFAULT_CAPACITY = 64;

    public ArrayList(){
        item = (E[]) new Object[DEFAULT_CAPACITY];
        numItems = 0;
    }

    public ArrayList(int n){
        item = (E[]) new Object[n];
        numItems = 0;
    }


    @Override
    public void add(int index, E x) {
        if(numItems >= item.length || index < 0 || index > numItems){
            throw new CustomException();
        }else{
            for(int i = numItems - 1; i >= index; i--){
                item[i + 1] = item[i];
            }
            item[index] = x;
            numItems++;
        }
    }

    @Override
    public void append(E x) {
        if(numItems >= item.length){
            throw new CustomException();
        }else{
            item[numItems++] = x;
        }

    }

    @Override
    public E remove(int index) {
        if(isEmpty() || index < 0 || index > numItems - 1){
            throw new CustomException();
        }else{
            E temp = item[index];
            for(int i = index; i <= numItems - 2; i++){
                item[i] = item[i + 1];
            }
            numItems--;
            return temp;
        }
    }

    @Override
    public boolean removeItem(E x) {
        int k = 0;
        while(k < numItems && ((Comparable) item[k]).compareTo(x) != 0){
            k++;
        }
        if(k == numItems){
            return false;
        }else{
            for(int i = k; i <= numItems - 2; i++){
                item[i] = item[i + 1];
            }
            numItems--;
            return true;
        }
    }

    @Override
    public E get(int index) {
        if(index >= 0 && index < numItems){
            return item[index];
        }else{
            throw new CustomException();
        }
    }

    @Override
    public void set(int index, E x) {
        if(index >= 0 && index < numItems){
            item[index] = x;
        }else{
            throw new CustomException();
        }

    }

    @Override
    public int indexOf(E x) {
        for(int i = 0 ; i < numItems; i++){
            if(((Comparable) item[i]).compareTo(x) == 0){
                return i;
            }
        }
        return -1;
    }

    @Override
    public int len() {
        return numItems;
    }

    @Override
    public boolean isEmpty() {
        return numItems == 0;
    }

    @Override
    public void clear() {
        item = (E[]) new Object[DEFAULT_CAPACITY];
        numItems = 0;
    }
}
```

​	알고리즘을 구현한 ArrayList 클래스입니다. 중간에 `indexOf` 와 `removeItem` 에 `((Comparable) item[i]).compareTo(x) == 0` 라고 사용한 부분이 있습니다. java.util.ArrayList 는 이 부분을 `equals` 로 구현하고 있습니다. `compareTo` 를 사용하면 주소값이 다르더라도 비교하려는 대상이 같으면 `0` 을 리턴할 수도 있습니다. 하지만 해당 클래스가 `Comparable` 을 상속해야 합니다.

​	반면 `equals` 는 `Object` 의 메서드로 모든 클래스에서 구현가능합니다. 하지만 클래스의 내용이 똑같아도 주소값이 다르다면 false 를 리턴합니다.

```java
import java.util.*;
import java.util.stream.Collectors;

public class Main implements Comparable<Main>{

    int size;

    public Main(int size){
        this.size = size;
    }

    public int add(int n) {
        return n + size;
    }

    @Override
    public int compareTo(Main o) {
        return Integer.compare(this.size, o.size);
    }

    public static void main(String[] args) {

        Main main = new Main(3);
        Main main2 = new Main(3);
        Main main3 = main;
        System.out.println(main.compareTo(main2) == 0); //true
        System.out.println(main.equals(main2)); //false
        System.out.println(main.equals(main3)); //true

        Integer a = 1000;
        Integer b = 1000;

        System.out.println(a.equals(b)); //true

    }
}
```

- 여기서 main 과 main2 는 내용물(size) 는 같지만 reference 자체가 다르므로 `equals` 에서 false 입니다. 하지만 `compareTo` 메서드의 구현체는 size 를 비교하므로 true(0) 이 나옵니다.
- main 과 main3 는 reference 가 같으므로 `equals` 에서 true 가 나옵니다.
- Integer 는 주소값이 다르지만 Primitive 로 바뀌면서 true 가 나옵니다.

즉, 다른 주소값이더라도 비교가 가능하도록 만들고 싶으면 `CompareTo` 를 사용하면 됩니다. 하지만 ArrayList 에 단순히 Wrapper 클래스만 넣을거면 `equals` 로도 충분히 값 비교가 가능합니다.



# 연결 리스트

연결 리스트는 원소가 추가될 때마다 공간을 할당받아 추가하는 방식으로, 배열의 공간 낭비를 피할 수 있는 자료구조입니다. 연결 리스트의 노드는 item 과 다음 노드를 가리키는 next 로 구성됩니다. item 은 Primitive type 이나 클래스 객체가 될 수 있습니다. next 는 다음 노드를 가리키는 링크입니다. 