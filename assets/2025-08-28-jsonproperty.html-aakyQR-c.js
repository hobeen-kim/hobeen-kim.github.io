import{_ as c,c as r,a,b as s,d as u,f as t,r as l,o as d,e as p}from"./app-CZii_kQ_.js";const k="/images/2025-08-28-jsonproperty/image-20250828142633576.png",v={},m={class:"table-of-contents"};function g(b,n){const o=l("Header"),e=l("router-link"),i=l("Footer");return d(),r("div",null,[a(o),s("nav",m,[s("ul",null,[s("li",null,[a(e,{to:"#문제-상황"},{default:t(()=>n[0]||(n[0]=[p("문제 상황")])),_:1}),s("ul",null,[s("li",null,[a(e,{to:"#문제-원인"},{default:t(()=>n[1]||(n[1]=[p("문제 원인")])),_:1})])])]),s("li",null,[a(e,{to:"#해결-방법"},{default:t(()=>n[2]||(n[2]=[p("해결 방법")])),_:1}),s("ul",null,[s("li",null,[a(e,{to:"#해결-방법-1-string-으로-받아서-변환"},{default:t(()=>n[3]||(n[3]=[p("해결 방법 1: String 으로 받아서 변환")])),_:1})]),s("li",null,[a(e,{to:"#해결-방법-2-jsondeserialize"},{default:t(()=>n[4]||(n[4]=[p("해결 방법 2: @JsonDeserialize")])),_:1}),s("ul",null,[s("li",null,[a(e,{to:"#jsondeserialize"},{default:t(()=>n[5]||(n[5]=[p("@JsonDeserialize")])),_:1})]),s("li",null,[a(e,{to:"#동작-방식"},{default:t(()=>n[6]||(n[6]=[p("동작 방식")])),_:1})]),s("li",null,[a(e,{to:"#적용"},{default:t(()=>n[7]||(n[7]=[p("적용")])),_:1})])])]),s("li",null,[a(e,{to:"#해결-방법-3-jsoncreator"},{default:t(()=>n[8]||(n[8]=[p("해결 방법 3: @JsonCreator")])),_:1}),s("ul",null,[s("li",null,[a(e,{to:"#jsoncreator"},{default:t(()=>n[9]||(n[9]=[p("@JsonCreator")])),_:1})]),s("li",null,[a(e,{to:"#적용-1"},{default:t(()=>n[10]||(n[10]=[p("적용")])),_:1})])])])])]),s("li",null,[a(e,{to:"#해결"},{default:t(()=>n[11]||(n[11]=[p("해결")])),_:1}),s("ul",null,[s("li",null,[a(e,{to:"#해결-방법-선택"},{default:t(()=>n[12]||(n[12]=[p("해결 방법 선택")])),_:1})]),s("li",null,[a(e,{to:"#jsondeserialize-vs-jsoncreator-비교"},{default:t(()=>n[13]||(n[13]=[p("@JsonDeserialize vs @JsonCreator 비교")])),_:1})])])]),s("li",null,[a(e,{to:"#ref"},{default:t(()=>n[14]||(n[14]=[p("Ref.")])),_:1})])])]),n[15]||(n[15]=u(`<h1 id="문제-상황" tabindex="-1"><a class="header-anchor" href="#문제-상황"><span>문제 상황</span></a></h1><p>고정된 타입을 정의할 때 주로 enum 을 사용한다. 예를 들어 디바이스의 타입이 AUTO-TRACTOR-1000, AUTO-COMBINE-2000 이 있다고 하자. 그러면 사용하는 enum 값을 다음과 같이 정의할 수 있다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">enum</span> <span class="token keyword">class</span> DeviceType <span class="token punctuation">{</span></span>
<span class="line">	AUTO_TRACTOR_1000<span class="token punctuation">,</span> AUTO_COMBINE_2000<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이 때 <strong>&quot;-&quot;(hyphen) 은 변수명으로 사용할 수 없으므로 &quot;_&quot;(underbar) 로 변경</strong>한다. 하지만 통용적으로 도메인에서, 그리고 다른 서버의 응답값으로 &quot;-&quot;(hyphen) 을 사용하고 있다고 가정하면 &quot;-&quot;(hyphen) 정보도 뺄 수 없으므로 <strong>typename</strong> 으로 두었다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">DeviceType</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">val</span> typeName<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">AUTO_TRACTOR_1000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-TRACTOR-1000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span>
<span class="line">  <span class="token function">AUTO_COMBINE_2000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-COMBINE-2000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이때 아래와 같이 다른 서버의 json 값이 해당 Enum 값인데 반환값에 &quot;-&quot;(hyphen) 을 사용하고 있다고 가정하자.</p><p><img src="`+k+`" alt="image-20250828142633576"></p><p>나는 아래와 같이 응답값을 받기 위해 DeviceInfo 를 만든 상황이다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">DeviceInfo</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">val</span> deviceId<span class="token operator">:</span> Long<span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">val</span> deviceType<span class="token operator">:</span> DeviceType</span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>그리고 아래와 같이 GET 요청을 restTemplate 으로 날리면 어떻게 될까?</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line">restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">externalServer</span></span><span class="token string">/api/v1/devies/1&quot;</span></span><span class="token punctuation">,</span></span>
<span class="line">  HttpMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span></span>
<span class="line">  requestEntity<span class="token punctuation">,</span></span>
<span class="line">  DeviceInfo<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java</span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>당연히 &quot;AUTO_TRACTOR-1000&quot; 은 enum 값에 포함되어있지 않으므로 아래와 같은 deserialize 에러가 발생한다.</p><blockquote><p>cannot deserialize value of type <code>com.hobeen.myserver.service.dto.DeviceType</code> from String &quot;AUTO-TRACTOR-1000&quot;: not one of the values accepted for Enum class: [AUTO_TRACTOR_1000, AUTO_COMBINE_2000]</p></blockquote><h2 id="문제-원인" tabindex="-1"><a class="header-anchor" href="#문제-원인"><span>문제 원인</span></a></h2><p>기본적으로 Jackson 은 클래스의 필드 타입에 맞게 자동으로 매핑을 수행한다. 하지만 경우에 따라 JSON 값과 객체 타입이 직접적으로 매칭되지 않는 경우가 있다.</p><p>Json 내 string 을 enum 값으로 변경할 떄 <code>com.fasterxml.jackson.databind.deser.std.EnumDeserializer</code> 가 동작한다. 이때 enum 의 name 값으로 찾게 된다. <code>AUTO-TRACTOR-1000</code> 는 당연히 enum 값이 아니므로 에러를 반환한다.</p><h1 id="해결-방법" tabindex="-1"><a class="header-anchor" href="#해결-방법"><span>해결 방법</span></a></h1><p>크게 두 가지 방법을 생각했다. 하나는 String 으로 받아서 직접 typeName 을 찾는 것, 두번째는 @JsonCreator 어노테이션 사용이다.</p><h2 id="해결-방법-1-string-으로-받아서-변환" tabindex="-1"><a class="header-anchor" href="#해결-방법-1-string-으로-받아서-변환"><span>해결 방법 1: String 으로 받아서 변환</span></a></h2><p>우선 Enum 클래스에서 typeName 을 enum 값으로 변경할 수 있도록 하는 메서드를 하나 선언한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">DeviceType</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">val</span> typeName<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">AUTO_TRACTOR_1000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-TRACTOR-1000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span>
<span class="line">  <span class="token function">AUTO_COMBINE_2000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-COMBINE-2000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">getDeviceTypeByTypeName</span><span class="token punctuation">(</span>typeName<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> FEUType <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> entries<span class="token punctuation">.</span><span class="token function">find</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>typeName <span class="token operator">==</span> typeName <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;DeviceType not found&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이제 typeName string 값으로 DeviceType 을 찾을 수 있게 되었다.</p><p>그리고 restTemplate 통신으로 응답을 받을 때 devieType 을 String 으로 받을 클래스를 만든다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">DeviceInfoInternal</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">val</span> deviceId<span class="token operator">:</span> Long<span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">val</span> deviceType<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>그리고 해당 클래스로 응답값을 받고 변환한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">val</span> response<span class="token operator">:</span> DeviceInfoInternal <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">externalServer</span></span><span class="token string">/api/v1/devies/1&quot;</span></span><span class="token punctuation">,</span></span>
<span class="line">  HttpMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span></span>
<span class="line">  requestEntity<span class="token punctuation">,</span></span>
<span class="line">  DeviceInfoInternal<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java</span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">val</span> deviceInfo<span class="token operator">:</span> DeviceInfo <span class="token operator">=</span> <span class="token function">DeviceInfo</span><span class="token punctuation">(</span></span>
<span class="line">  deviceId <span class="token operator">=</span> response<span class="token punctuation">.</span>deviceId<span class="token punctuation">,</span> </span>
<span class="line">  deviceType <span class="token operator">=</span> DeviceType<span class="token punctuation">.</span><span class="token function">getDeviceTypeByTypeName</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>deviceType<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>하지만 이는 다음과 같은 문제점이 있다.</p><ol><li>변환 과정이 추가적으로 필요</li><li>external 서버에 대한 요청을 하는 코드마다 변환 과정이 필요해서 수정의 어려움</li></ol><h2 id="해결-방법-2-jsondeserialize" tabindex="-1"><a class="header-anchor" href="#해결-방법-2-jsondeserialize"><span>해결 방법 2: @JsonDeserialize</span></a></h2><h3 id="jsondeserialize" tabindex="-1"><a class="header-anchor" href="#jsondeserialize"><span>@JsonDeserialize</span></a></h3><p><code>@JsonDeserialize</code>는 <strong>Jackson 라이브러리</strong>에서 제공하는 어노테이션으로, JSON 문자열을 자바/Kotlin 객체로 역직렬화(deserialization)할 때 <strong>커스텀 로직을 지정</strong>할 수 있게 해준다.</p><h3 id="동작-방식" tabindex="-1"><a class="header-anchor" href="#동작-방식"><span>동작 방식</span></a></h3><ol><li><strong>JSON 문자열 수신</strong> → Jackson ObjectMapper가 객체로 변환 시도</li><li><strong><code>@JsonDeserialize(using = ...)</code> 발견</strong> → 지정된 <code>JsonDeserializer</code> 구현체가 호출됨</li><li><strong>커스텀 로직 실행</strong> → JSON 값 → 원하는 객체 타입으로 변환</li><li><strong>객체 필드에 주입</strong></li></ol><p>즉, 단순히 매핑이 불가능한 경우에도 원하는 규칙을 직접 정의하여 매끄럽게 변환할 수 있다.</p><h3 id="적용" tabindex="-1"><a class="header-anchor" href="#적용"><span>적용</span></a></h3><p>아래와 같이 DeviceTypeDeserializer 클래스를 생성한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">class</span> DeviceTypeDeserializer<span class="token operator">:</span> JsonDeserializer<span class="token operator">&lt;</span>DeviceType<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>p<span class="token operator">:</span> JsonParser<span class="token punctuation">,</span> ctxt<span class="token operator">:</span> DeserializationContext<span class="token punctuation">)</span><span class="token operator">:</span> DeviceType <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> codec <span class="token operator">=</span> p<span class="token punctuation">.</span>codec</span>
<span class="line">        <span class="token keyword">val</span> node <span class="token operator">=</span> codec<span class="token punctuation">.</span>readTree<span class="token operator">&lt;</span>TextNode<span class="token operator">&gt;</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> DeviceType<span class="token punctuation">.</span><span class="token function">getDeviceTypeByTypeName</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>그리고 다음과 같이 json 의 deserialize 로 해당 Deserializer 를 사용한다고 선언하면(어노테이션을 븥이면) 정상적으로 동작한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@JsonDeserialize</span><span class="token punctuation">(</span>using <span class="token operator">=</span> DeviceTypeDeserializer<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">DeviceType</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">val</span> typeName<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">AUTO_TRACTOR_1000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-TRACTOR-1000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span>
<span class="line">  <span class="token function">AUTO_COMBINE_2000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-COMBINE-2000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">getDeviceTypeByTypeName</span><span class="token punctuation">(</span>typeName<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> FEUType <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> entries<span class="token punctuation">.</span><span class="token function">find</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>typeName <span class="token operator">==</span> typeName <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;DeviceType not found&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="해결-방법-3-jsoncreator" tabindex="-1"><a class="header-anchor" href="#해결-방법-3-jsoncreator"><span>해결 방법 3: @JsonCreator</span></a></h2><h3 id="jsoncreator" tabindex="-1"><a class="header-anchor" href="#jsoncreator"><span>@JsonCreator</span></a></h3><p><code>@JsonCreator</code>는 <strong>Jackson</strong>에서 제공하는 애너테이션으로, JSON 문자열을 객체로 <strong>역직렬화(deserialization)</strong> 할 때 어떤 생성자나 팩토리 메서드를 사용할지 지정할 수 있다. 기본적으로 Jackson은 매개변수 없는 생성자(no-args constructor)나 기본 생성 로직을 사용하지만, 경우에 따라 특정 생성자나 정적 메서드(팩토리 메서드)를 통해 객체를 생성하도록 강제할 수 있다.</p><p>Kotlin의 <code>enum</code>에서 JSON 문자열이 단순히 <code>enum.name</code>과 일치하지 않는 경우, <code>@JsonCreator</code>를 통해 커스텀 매핑 로직을 지정하면 편리하다.</p><p><strong>@JvmStatic 을 사용하는 이유</strong></p><ul><li>Jackson은 <strong>Java 기반</strong> 라이브러리이므로, 정적 메서드를 찾을 때 <strong>JVM static 메서드</strong>를 기대한다.</li><li>Kotlin의 <code>companion object</code> 안에 정의된 함수는 기본적으로 인스턴스 메서드처럼 보이므로, <code>@JvmStatic</code>을 붙여줘야 Java의 정적 메서드처럼 인식된다.</li><li>따라서 <code>@JsonCreator</code>를 companion object 안에서 사용할 때는 <code>@JvmStatic</code>을 반드시 붙여야 Jackson이 해당 메서드를 팩토리 메서드로 호출할 수 있다.</li></ul><h4 id="mode" tabindex="-1"><a class="header-anchor" href="#mode"><span>mode</span></a></h4><p><code>@JsonCreator</code>는 <code>mode</code> 옵션을 통해 JSON → 객체 변환 방식을 세밀하게 제어할 수 있다.</p><ul><li><strong>DEFAULT</strong><ul><li>Jackson이 매개변수의 개수나 이름을 보고 자동으로 매핑 방식을 선택한다.</li><li>일반적으로 대부분의 경우 이 모드로 충분하다.</li></ul></li><li><strong>DELEGATING</strong><ul><li>JSON 전체 값을 <strong>하나의 인자</strong>로 넘겨서 생성자를 호출한다.</li><li>예: <code>&quot;{ &quot;typeName&quot;: &quot;AUTO-TRACTOR-1000&quot; }&quot;</code> → 문자열 <code>&quot;AUTO-TRACTOR-1000&quot;</code> 하나만 받아 enum 매핑</li></ul></li><li><strong>PROPERTIES</strong><ul><li>JSON 객체의 각 프로퍼티를 <strong>생성자의 파라미터</strong>와 일대일로 매핑한다.</li><li>예: <code>&quot;{ &quot;typeName&quot;: &quot;AUTO-TRACTOR-1000&quot;, &quot;other&quot;: 123 }&quot;</code> → 생성자의 <code>(typeName, other)</code> 파라미터에 각각 매핑</li></ul></li><li><strong>DISABLED</strong><ul><li><code>@JsonCreator</code>를 완전히 비활성화한다.</li><li>문서상 존재하는 값이더라도 매핑되지 않도록 할 때 사용한다.</li></ul></li></ul><h3 id="적용-1" tabindex="-1"><a class="header-anchor" href="#적용-1"><span>적용</span></a></h3><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">DeviceType</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">val</span> typeName<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">AUTO_TRACTOR_1000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-TRACTOR-1000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span>
<span class="line">  <span class="token function">AUTO_COMBINE_2000</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;AUTO-COMBINE-2000&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token annotation builtin">@JvmStatic</span></span>
<span class="line">  <span class="token annotation builtin">@JsonCreator</span><span class="token punctuation">(</span>mode <span class="token operator">=</span> JsonCreator<span class="token punctuation">.</span>Mode<span class="token punctuation">.</span>DELEGATING<span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">getDeviceTypeByTypeName</span><span class="token punctuation">(</span>typeName<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> FEUType <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> entries<span class="token punctuation">.</span><span class="token function">find</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>typeName <span class="token operator">==</span> typeName <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;DeviceType not found&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="해결" tabindex="-1"><a class="header-anchor" href="#해결"><span>해결</span></a></h1><h2 id="해결-방법-선택" tabindex="-1"><a class="header-anchor" href="#해결-방법-선택"><span>해결 방법 선택</span></a></h2><p>해결 방법은 1번을 제외하고, 2, 3번을 비교했고 최종적으로 3번을 선택했다. 그 이유는 JsonDeserialize 를 사용할만큼 복잡한 변환이 필요없기 때문이다.</p><ul><li><strong>복잡한 JSON 변환 로직</strong>이 필요한 경우 → <code>@JsonDeserialize</code></li><li><strong>간단한 enum/string 매핑</strong>처럼 직관적인 경우 → <code>@JsonCreator</code></li></ul><h2 id="jsondeserialize-vs-jsoncreator-비교" tabindex="-1"><a class="header-anchor" href="#jsondeserialize-vs-jsoncreator-비교"><span><code>@JsonDeserialize</code> vs <code>@JsonCreator</code> 비교</span></a></h2><table><thead><tr><th>구분</th><th>@JsonDeserialize</th><th>@JsonCreator</th></tr></thead><tbody><tr><td><strong>개념</strong></td><td>Jackson이 역직렬화 시 사용할 <strong>커스텀 Deserializer 클래스</strong>를 지정</td><td>역직렬화 시 사용할 <strong>생성자/정적 팩토리 메서드</strong>를 지정</td></tr><tr><td><strong>사용 방식</strong></td><td><code>@JsonDeserialize(using = CustomDeserializer::class)</code></td><td><code>@JsonCreator</code>를 생성자/companion object 메서드에 붙여 사용</td></tr><tr><td><strong>적용 범위</strong></td><td>특정 클래스/필드 단위로 지정 가능 (세밀한 제어 가능)</td><td>클래스 레벨에서 객체 생성 로직 자체를 정의</td></tr><tr><td><strong>구현 난이도</strong></td><td>별도의 <code>JsonDeserializer&lt;T&gt;</code> 클래스 구현 필요 → 코드 길어짐</td><td>간단히 정적 메서드로 처리 가능 → 코드 간결</td></tr><tr><td><strong>유연성</strong></td><td>복잡한 파싱 로직 (JSON 구조 변환, 값 후처리 등) 처리 가능</td><td>주로 <strong>단일 값 → 객체</strong> 매핑에 적합</td></tr><tr><td><strong>Kotlin enum 처리</strong></td><td>enum 매핑 시에도 커스텀 로직 가능 (복잡한 변환 지원)</td><td>enum 매핑에서 단순 문자열 ↔ enum 변환에 가장 적합</td></tr><tr><td><strong>장점</strong></td><td>- 복잡한 JSON 구조 변환 가능 - 여러 필드 기반의 변환 지원 - 재사용성 높음</td><td>- 코드가 간결 - 별도 클래스 필요 없음 - enum 매핑에 직관적</td></tr><tr><td><strong>단점</strong></td><td>- 별도 클래스 파일 필요 → 유지보수 번거로움 - 간단한 매핑에는 오버킬</td><td>- 복잡한 JSON 구조 변환에는 부적합 - 주로 단순 매핑에만 유용</td></tr></tbody></table><h1 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>Ref.</span></a></h1><p>없음��</p>`,58)),a(i)])}const y=c(v,[["render",g],["__file","2025-08-28-jsonproperty.html.vue"]]),T=JSON.parse('{"path":"/posts/spring/2025-08-28-jsonproperty.html","title":"json 응답값을 변형해서 받기","lang":"en-US","frontmatter":{"title":"json 응답값을 변형해서 받기","date":"2025-08-28T00:00:00.000Z","tags":["json","enum"],"description":"서버에서 응답으로 받는 enum 값과 실제 enum name 이 다를 때 해결"},"headers":[{"level":1,"title":"문제 상황","slug":"문제-상황","link":"#문제-상황","children":[{"level":2,"title":"문제 원인","slug":"문제-원인","link":"#문제-원인","children":[]}]},{"level":1,"title":"해결 방법","slug":"해결-방법","link":"#해결-방법","children":[{"level":2,"title":"해결 방법 1: String 으로 받아서 변환","slug":"해결-방법-1-string-으로-받아서-변환","link":"#해결-방법-1-string-으로-받아서-변환","children":[]},{"level":2,"title":"해결 방법 2: @JsonDeserialize","slug":"해결-방법-2-jsondeserialize","link":"#해결-방법-2-jsondeserialize","children":[{"level":3,"title":"@JsonDeserialize","slug":"jsondeserialize","link":"#jsondeserialize","children":[]},{"level":3,"title":"동작 방식","slug":"동작-방식","link":"#동작-방식","children":[]},{"level":3,"title":"적용","slug":"적용","link":"#적용","children":[]}]},{"level":2,"title":"해결 방법 3: @JsonCreator","slug":"해결-방법-3-jsoncreator","link":"#해결-방법-3-jsoncreator","children":[{"level":3,"title":"@JsonCreator","slug":"jsoncreator","link":"#jsoncreator","children":[]},{"level":3,"title":"적용","slug":"적용-1","link":"#적용-1","children":[]}]}]},{"level":1,"title":"해결","slug":"해결","link":"#해결","children":[{"level":2,"title":"해결 방법 선택","slug":"해결-방법-선택","link":"#해결-방법-선택","children":[]},{"level":2,"title":"@JsonDeserialize vs @JsonCreator 비교","slug":"jsondeserialize-vs-jsoncreator-비교","link":"#jsondeserialize-vs-jsoncreator-비교","children":[]}]},{"level":1,"title":"Ref.","slug":"ref","link":"#ref","children":[]}],"git":{},"filePathRelative":"_posts/spring/2025-08-28-jsonproperty.md"}');export{y as comp,T as data};
