import{_ as d,c as k,a,b as l,d as c,f as i,r as s,o as u,e as r}from"./app-CslWHMGM.js";const f={},p={class:"table-of-contents"};function h(_,e){const o=s("Header"),t=s("router-link"),n=s("Footer");return u(),k("div",null,[a(o),l("nav",p,[l("ul",null,[l("li",null,[a(t,{to:"#_0-문제-상황"},{default:i(()=>e[0]||(e[0]=[r("0. 문제 상황")])),_:1})]),l("li",null,[a(t,{to:"#_1-문제-원인"},{default:i(()=>e[1]||(e[1]=[r("1. 문제 원인")])),_:1})]),l("li",null,[a(t,{to:"#_2-kafka-설정"},{default:i(()=>e[2]||(e[2]=[r("2. kafka 설정")])),_:1}),l("ul",null,[l("li",null,[a(t,{to:"#_2-1-설정-설명"},{default:i(()=>e[3]||(e[3]=[r("2.1 설정 설명")])),_:1})])])]),l("li",null,[a(t,{to:"#_2-2-참고사항"},{default:i(()=>e[4]||(e[4]=[r("2.2 참고사항")])),_:1})]),l("li",null,[a(t,{to:"#ref"},{default:i(()=>e[5]||(e[5]=[r("Ref.")])),_:1})])])]),e[6]||(e[6]=c(`<h1 id="_0-문제-상황" tabindex="-1"><a class="header-anchor" href="#_0-문제-상황"><span>0. 문제 상황</span></a></h1><ul><li><p>Local 에서 카프카 실행 (localhost:9092)</p></li><li><p>docker (python) 으로 카프카에 produce (host.docker.internal:9092), 하지만 timeout 에러</p><ul><li><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">KafkaTimeoutError: Batch for TopicPartition(topic=&#39;raw-article&#39;, partition=1) containing 1 record(s) expired: 30 seconds have passed since batch creation plus linger time</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul><h1 id="_1-문제-원인" tabindex="-1"><a class="header-anchor" href="#_1-문제-원인"><span>1. 문제 원인</span></a></h1><ul><li>kafka 는 어떤 서버와 연결할지 advertised.listeners 를 가지고 있으며 기본은 localhost 다.</li><li>docker 에서는 host.docker.internal 로 접근하므로 해당 도메인도 열어줘야 한다.</li></ul><h1 id="_2-kafka-설정" tabindex="-1"><a class="header-anchor" href="#_2-kafka-설정"><span>2. kafka 설정</span></a></h1><ul><li>~/kafka/kafka_2.13-3.9.0/config/server.properties 에 echo 를 통해 설정 추가한다.</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">echo &quot;listeners=LOCAL://localhost:9092,DOCKER://localhost:29092&quot; &gt;&gt; ~/kafka/kafka_2.13-3.9.0/config/server.properties</span>
<span class="line">echo &quot;advertised.listeners=LOCAL://localhost:9092,DOCKER://host.docker.internal:29092&quot; &gt;&gt; ~/kafka/kafka_2.13-3.9.0/config/server.properties</span>
<span class="line">echo &quot;listener.security.protocol.map=LOCAL:PLAINTEXT,DOCKER:PLAINTEXT&quot; &gt;&gt; ~/kafka/kafka_2.13-3.9.0/config/server.properties</span>
<span class="line">echo &quot;inter.broker.listener.name=LOCAL&quot; &gt;&gt; ~/kafka/kafka_2.13-3.9.0/config/server.properties</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-1-설정-설명" tabindex="-1"><a class="header-anchor" href="#_2-1-설정-설명"><span>2.1 설정 설명</span></a></h2><ul><li>listeners <ul><li>Kafka 브로커가 <strong>실제로 바인딩하는</strong> 네트워크 인터페이스와 포트</li><li>localhost:9092 와 localhost:29092 에서만 연결을 수신한다. 생산자와 소비자는 해당 도메인으로 접근해야 한다. 즉 로컬에서만 접근할 수 있다. 0.0.0.0 으로 하면 퍼블릭하게 접근할 수 있다는 뜻이다.</li></ul></li><li>advertised.listeners <ul><li>Kafka가 클라이언트에게 <strong>알려주는</strong> 연결 주소로 클라이언트가 실제로 연결할 때 사용하는 주소다.</li><li>로컬 클라이언트와 도커 클라이언트는 <code>localhost:9092</code> 또는 <code>host.docker.internal:29092</code>로 접속해야 한다.</li></ul></li><li>listener.security.protocol.map <ul><li>리스너가 어떤 보안 프로토콜을 사용할지 정의하는 설정 <ul><li>PLAINTEXT: 암호화되지 않은 일반 TCP 연결</li><li>SSL: SSL/TLS 암호화 통신</li><li>SASL_PLAINTEXT: SASL 인증 (암호화 없음)</li><li>SASL_SSL: SASL 인증 + SSL 암호화</li></ul></li><li>LOCAL:PLAINTEXT 이면 LOCAL 을 사용하는 도메인은 PLAINTEXT 를 사용한다는 뜻이다.</li></ul></li><li>inter.broker.listener.name <ul><li>Kafka 브로커들 간의 내부 통신에 사용할 리스너를 지정하는 설정</li><li>LOCAL 이므로 localhost:9092 를 사용한다는 뜻이다</li></ul></li></ul><h1 id="_2-2-참고사항" tabindex="-1"><a class="header-anchor" href="#_2-2-참고사항"><span>2.2 참고사항</span></a></h1><ul><li>advertised.listeners 을 설정할 때 포트가 겹치면 안된다. 나는 9092 와 29092 로 나눴다.</li><li>kafka 가 실행안된다면 <code>~/kafka/kafka_2.13-3.9.0/logs/server.log</code> 에서 로그를 확인할 수 있다.</li></ul><h1 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>Ref.</span></a></h1><p><a href="https://stackoverflow.com/questions/62213671/how-to-solve-kafka-errors-kafkatimeouterror-kafkatimeouterror-failed-to-update" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/62213671/how-to-solve-kafka-errors-kafkatimeouterror-kafkatimeouterror-failed-to-update</a></p>`,13)),a(n)])}const m=d(f,[["render",h],["__file","2025-01-18-kafkadocker.html.vue"]]),g=JSON.parse('{"path":"/posts/kafka/2025-01-18-kafkadocker.html","title":"도커에서 카프카 접근하기","lang":"en-US","frontmatter":{"title":"도커에서 카프카 접근하기","date":"2025-01-18T00:00:00.000Z","tags":["kafka","docker"],"description":"도커에서 카프카 연결하는 방법"},"headers":[{"level":1,"title":"0. 문제 상황","slug":"_0-문제-상황","link":"#_0-문제-상황","children":[]},{"level":1,"title":"1. 문제 원인","slug":"_1-문제-원인","link":"#_1-문제-원인","children":[]},{"level":1,"title":"2. kafka 설정","slug":"_2-kafka-설정","link":"#_2-kafka-설정","children":[{"level":2,"title":"2.1 설정 설명","slug":"_2-1-설정-설명","link":"#_2-1-설정-설명","children":[]}]},{"level":1,"title":"2.2 참고사항","slug":"_2-2-참고사항","link":"#_2-2-참고사항","children":[]},{"level":1,"title":"Ref.","slug":"ref","link":"#ref","children":[]}],"git":{},"filePathRelative":"_posts/kafka/2025-01-18-kafkadocker.md"}');export{m as comp,g as data};
