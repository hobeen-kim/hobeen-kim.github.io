---
categories: "codestates"
tag: ["HTTPS", "Hashing", "Cookie"]
title: "[codestates] 인증 및 보안"
---

# HTTPS

​	`HTTPS`에서는 클라이언트와 서버가 데이터를 암호화하여 주고받기 위해 **비대칭키 방식과 대칭키 방식을 혼용하여 사용**합니다.

​	HTTPS는 먼저 **비대칭키 방식으로 대칭키를** 주고받도록 합니다. 이후 클라이언트와 서버가 **데이터를 주고받을 때는 대칭키를 사용**합니다. 비대칭키 알고리즘은 대칭키 알고리즘보다 훨씬 복잡하기 때문에 대칭키를 사용하여 데이터를 암호화 및 복호화하는 것이 훨씬 컴퓨터에 부담을 덜 주기 때문입니다.

# Hashing

​	해싱은 복호화가 불가능한 암호화 방식입니다. 다음과 같은 특징이 있습니다.

- 항상 같은 길이의 문자열을 리턴합니다.
- 서로 다른 문자열에 동일한 해시 함수를 사용하면 반드시 다른 결과값이 나옵니다.
- 동일한 문자열에 동일한 해시 함수를 사용하면 항상 같은 결과값이 나옵니다.

해싱은 복호화가 불가능하기 때문에 한번 저장하면 원래 값을 알아낼 수 없습니다. 따라서 비밀번호를 관리할 때 효과적입니다. 서버 측에서는 원래 비밀번호를 모르는 상태에서, 해싱한 값끼리 비교해서 일치하는지 확인합니다. 꼭 정확한 값을 몰라도, 해싱한 값이 일치한다면 정확한 비밀번호를 입력했다는 뜻이 되기 때문에, 해싱 값으로만 로그인 요청을 처리하는 데에도 전혀 문제가 없게 됩니다.

# Cookie

쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법 중 하나입니다. 하지만 **데이터를 저장한 이후 아무 때나 데이터를 가져올 수 없습니다. 데이터를 저장한 이후 특정 조건들이 만족하는 경우에만 다시 가져올 수 있습니다.** 이런 조건들을 **쿠키 옵션**이라고 합니다.

## Domain

​	만약 쿠키 옵션에서 도메인 정보가 존재한다면 클라이언트에서는 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키를 전송할 수 있습니다. 이를 통해 `naver.com`에서 받은 쿠키를 `google.com`에 전송하는 일을 막을 수 있습니다.

## Path

세부 경로는 서버가 라우팅 할 때 사용하는 경로입니다. Path 옵션의 특징은 설정된 path를 전부 만족하는 경우 요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송할 수 있습니다. 즉 `Path`가 `/users`로 설정되어 있고, 요청하는 세부 경로가 `/users/codestates`인 경우라면 쿠키 전송이 가능합니다.

## MaxAge or Expires

​	MaxAge는 앞으로 몇 초 동안 쿠키가 유효한지 설정하는 옵션입니다. Expires 은 언제까지 유효한지 `Date`를 지정합니다. 이때 클라이언트의 시간을 기준으로 합니다. 이후 지정된 시간, 날짜를 초과하게 되면 쿠키는 자동으로 파괴됩니다.

- **세션 쿠키:** `MaxAge` 또는 `Expires` 옵션이 없는 쿠키로, 브라우저가 실행 중일 때 사용할 수 있는 임시 쿠키입니다. 브라우저를 종료하면 해당 쿠키는 삭제됩니다.
- **영속성 쿠키:** 브라우저의 종료 여부와 상관없이 `MaxAge` 또는 `Expires`에 지정된 유효시간만큼 사용가능한 쿠키입니다.

## Secure

쿠키를 전송해야 할 때 사용하는 프로토콜에 따른 쿠키 전송 여부를 결정합니다. 만약 해당 옵션이 `true`로 설정된 경우, 'HTTPS' 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있습니다.

## HttpOnly

​	자바스크립트에서 브라우저의 쿠키에 접근 여부를 결정합니다. 만약 해당 옵션이 `true`로 설정된 경우, 자바스크립트에서는 쿠키에 접근이 불가합니다.

​	명시되지 않는 경우 기본으로 `false`로 지정되어 있습니다. 만약 이 옵션이 `false`인 경우 자바스크립트에서 쿠키에 접근이 가능하므로 'XSS' 공격에 취약합니다.

## SameSite

Cross-Site 요청을 받은 경우, 요청에서 사용한 메서드(e.g. GET, POST, PUT, PATCH …)와 해당 옵션의 조합을 기준으로 서버의 쿠키 전송 여부를 결정하게 됩니다. 

Cross-Site : eTLD+1이 다른 경우 Cross-Site로 구분됩니다. 여기서 eTLD+1 이란, `.com`, `.org`과 같이 도메인의 가장 마지막 부분을 TLD(Top Level Domain, 최상위 도메인)라고 하는데, 이 최상위 도메인의 바로 왼쪽의 하위 레벨 도메인을 합한 것을 eTLD+1 이라고 합니다. 참고로, 요즘 자주 볼 수 있는 `.io`의 경우 바로 왼쪽의 주소를 하나 더 합한 것을 TLD라고 판단합니다.

- `http://codestates.com` **vs** `https://codestates.com` ⇒ 두 주소 모두 TLD는 `.com`, eTLD+1은 `codestates.com`으로 같으므로 Same-Site입니다.
- `https://code.github.io` **vs** `https://states.github.io` ⇒ 두 주소 모두 TLD는 `.io`, eTLD는 `github.io`이며 , eTLD+1은 각각 `code.github.io`, `states.github.io`로 다르므로 Cross-Site입니다.

SameSite 옵션에서 사용할 수 있는 속성은 다음과 같습니다.

- Lax: Cross-Site 요청이라면 GET 메서드에 대해서만 쿠키를 전송할 수 있습니다.
- Strict: 단어 그대로 가장 엄격한 옵션으로, Cross-Site가 아닌 Same-Site인 경우에만 쿠키를 전송할 수 있습니다.
- None: Cross-Site에 대해 가장 관대한 옵션으로 항상 쿠키를 보내줄 수 있습니다. 다만 쿠키 옵션 중 Secure 옵션이 필요합니다.