---
categories: "interview"
title: "[자료구조/알고리즘] 인터뷰 - 자료구조 및 알고리즘"
description: "면접을 위한 자료구조, 알고리즘 인터뷰 정리입니다."
series: "인터뷰 정리"
tag: [""]
---

[해당 페이지](https://github.com/ksundong/backend-interview-question)를 기반으로 작성했습니다.

# 자료구조

### 배열과 링크드 리스트의 차이를 설명해주세요.

배열은 메모리상에 순서대로 데이터를 저장합니다. 반면 링크드 리스트는 다음 데이터의 위치에 대한 포인터를 가지고 있는 구조입니다.

배열은 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있습니다.

링크드 리스트는 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다는 장점이 있습니다.

### List와 Set의 차이에 대해서 설명해주세요.

List는 **중복**된 데이터를 저장하고 순서를 유지하는 선형 자료구조이고, Set은 **중복**되지 않은 데이터를 저장할 수 있고, 일반적으로 순서를 유지하지 않는 선형 자료구조입니다. (Set은 집합입니다., TreeSet과 같이 순서를 유지하는 Set도 존재합니다.)

### 해시 구조에 대해 설명해주세요.

다른 자료구조와 해시 테이블의 차이점은 해시 테이블은 키 자신의 값에 따라 자리가 결정된다는 것입니다. 키값과 해시 함수를 통해 주소값을 결정한 후 해당 위치에 값을 저장합니다. 따라서 기본적으로 수정, 삭제, 삽입 등의 작업에서 상수 시간의 시간 복잡도를 가집니다.

해시 테이블의 중요한 장애물은 같은 해시값을 가지는 '**충돌**' 인데 체이닝이나 개방 주소법으로 해결합니다. 또한 해시 테이블의 원소가 차 있는 비율은 해시 테이블 성능에 중요한 영향을 미치는데, 이 비율을 적재율이라고 합니다. **적재율이 높을수록 충돌확률이 높아져서 해시 테이블의 성능이 나빠집니다.**

### Stack, Queue에 대해서 설명해주세요.

**Stack**

스택은 선형 자료구조의 일종으로 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)방식의 자료구조 입니다. 스택의 사용 예시로는 웹 브라우저의 방문기록(뒤로가기), 실행 취소(undo) 등이 있습니다.

**Queue**

큐는 선형 자료구조의 일종으로 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)방식의 자료구조 입니다. 큐의 사용 예시로는 프린터의 인쇄 대기, 콜센터 고객 대기 시간 등이 있습니다.

### 선택 정렬

```java
public void selectionSort(){
    int k;
    int tmp;
    for(int last = A.length - 1; last >= 1; last--){
        k = theLargest(last); //last 인덱스 이하에서 가장 값의 큰 인덱스 구하기
        tmp = A[k];
        A[k] = A[last];
        A[last] = tmp;
    }
}

private int theLargest(int last){
    int largest = 0;
    for(int i = 0; i <= last; i++){
        if(A[i] > A[largest]){
            largest = i;
        }
    }
    return largest;
}
```

### 버블 정렬

```java
public void bubbleSort(){
    boolean swapped;

    for(int last = A.length - 1; last >= 2; last--){
        swapped = false;
        for(int i = 0; i <= last - 1; i++){
            if(A[i] > A[i + 1]){
                int tmp = A[i];
                A[i] = A[i + 1];
                A[i + 1] = tmp;
                swapped = true;
            }
        }
        if(!swapped) break;
    }
}
```

### 삽입 정렬

​	삽입정렬은 최악의 경우와 평균인 상황에서  θ(n^2) 의 시간복잡도를 가집니다. 하지만 배열이 정렬되어있을 경우 while 문은 실행되지 않기 때문에  θ(n) 가 됩니다. 따라서 배열이 거의 정렬되어 있다면 삽입 정렬를 사용하는 것이 효과적입니다.

```java
public void insertionSort(){
    for(int i = 1; i < A.length - 1; i++){
        int location = i - 1;
        int tmp = A[i];
        while(location >= 0 && tmp < A[location]){
            A[location + 1] = A[location];
            location--;
        }
        A[location + 1] = tmp;
    }
}
```

### 병합정렬

```java
public void mergeSort(){
    int[] B = new int[A.length];
    mSort(0, A.length - 1, B);
}

private void mSort(int p, int r, int[] B){
    if(p < r){
        int q = (p + r) / 2;
        mSort(p, q, B);
        mSort(q + 1, r, B);
        merge(p, q, r, B);
    }
}

private void merge(int p, int q, int r, int[] B){
    int i = p;
    int j = q + 1;
    int t = 0;

    //앞뒤 남았을 때
    while(i <= q && j <= r){
        if(A[i] <= A[j]) B[t++] = A[i++];
        else B[t++] = A[j++];
    }

    //앞만 남았을 때
    while(i <= q){
        B[t++] = A[i++];
    }
    //뒤만 남았을 때
    while(j <= r){
        B[t++] = A[j++];
    }
    i = p;
    t = 0;
    while(i <= r){
        A[i++] = B[t++];
    }
}
```

### 퀵정렬

​	퀵정렬의 시간복잡도는 평균 θ(nlongn) 입니다. 병합정렬과 마찬가지로 정렬하는 데 n 번, 각각이 평균적으로 절반으로 쪼개진다고 가정하면 쪼개지는 개수가 logn 번 입니다. 하지만 최악의 경우에는 θ(n^2) 으로, 한쪽으로 계속 몰리는 경우입니다. 그러면 n/(n-1)/2 번 수행됩니다. 한쪽으로만 몰리지 않아도 극심하게 균형이 맞지 않으면 시간은 역시 θ(n^2) 가 됩니다.

​	입력이 이미 정렬되어 있거나 거의 정렬되어 있는 경우에도 균형이 맞지 않기 때문에  θ(n^2) 입니다. 역순 정렬일 때도 마찬가지 입니다. 이럴 경우를 방지하고자 한다면 기준 원소를 맨 앞이나 맨 뒤로 잡지 말고 임의의 한 원소를 고르면 됩니다.

​	또한 동일한 원소가 많이 존재하는 경우에도 분할의 균형이 맞지가 않아 수행횟수가 많아질 수 있으며, 극단적으로 모두 동일할 경우 이미 정렬된 상태처럼 균형이 항상 최악이 됩니다. 이 문제를 해결하기 위해서는 기준 원소와 동일한 원소를 만날 때 양쪽에 골고루 나누어주도록 변경하면 됩니다.

```java
public void quickSort(){
    qSort(0, A.length - 1);
}

private void qSort(int p, int r){
    if(p < r){
        int q = partition(p, r);
        qSort(p, q - 1);
        qSort(q + 1, r);
    }
}

private int partition(int p, int r){
    int i = p - 1;
    int tmp;
    for(int j = p; j < r; j++){
        if(A[r] < A[j]){
            tmp = A[++i];
            A[i] = A[j];
            A[j] = tmp;
        }
    }
    tmp = A[++i];
    A[i] = A[r];
    A[r] = tmp;
    return i;
}
```



### 힙정렬

​	힙 정렬은 힙 자료구조를 사용해서 정렬을 합니다. 먼저 배열 A[0...n-1] 을 buildHeap() 으로 힙 자료구조로 만듭니다. 루트 노드가 제일 큰 원소이니 루트노드와 마지막 리프노드를 변경한 후 percolateDown() 으로 수선해줍니다.

![image-20230523142936838](../../images/2023-09-28-[자료구조알고리즘] 인터뷰 - 자료구조 및 알고리즘/image-20230523142936838.png)

​	힙 구조인 [9, 7, 8, 4, 3, 3, 5, 1 2] 에서 위 그림과 같이 A[0] 과 A[8] 의 자리를 바꿔줍니다. 그리고 A[0] 에 대해 percolateDown() 을 진행합니다. 그러면 A[8] 은 정렬되었고 다시 A[0] 와 A[7] 을 변경해주면 됩니다. 이런 식으로 모든 배열을 정렬합니다.

​	힙정렬의 수행시간은 평균 θ(nlongn) 이며 최악의 경우에도 θ(nlongn) 입니다. 최선의 경우는 모든 원소가 동일한 경우로 θ(n) 시간에 끝납니다. 또한 힙정렬은 In-place Sorting 입니다.

```java
public void heapSort(){
    buildHeap();
    int tmp;
    for(int i = A.length - 1; i >= 1; i--){
        tmp = A[0];
        A[0] = A[i];
        A[i] = tmp;
        percolateDown(0, i - 1);
    }
}

private void percolateDown(int i, int n){ //i 부터 n 까지 percolateDown
    int child = 2 * i + 1;
    int right = 2 * i + 2;
    if(child <= n){
        if(right <= n && A[child] < A[right]){
            child = right;
        }
        if(A[i] < A[child]){
            int temp = A[i];
            A[i] = A[child];
            A[child] = temp;
            percolateDown(child, n);
        }
    }
}

private void buildHeap(){
    if(A.length >= 2){
        for(int i = (A.length - 2) / 2; i >= 0; i--){
            percolateDown(i, A.length - 1);
        }
    }
}
```



### 셸정렬

​	셸 정렬은 삽입 정렬의 평균 시간이 θ(n) 임을 활용한 정렬입니다. 삽입 정렬은 이미 정렬되어있거나 거의 정렬되어 있으면 시간은 θ(n) 이 됩니다. 셸 정렬은 배열 전체를 특정 간격으로 나누어 삽입 정렬을 한 다음, 더 좁아진 간격으로 다시 삽입 정렬을 합니다. 마지막으로 간격이 1 이 되면 전체가 하나의 그룹으로 삽입 정렬을 하고 끝이 납니다.

​	이 간격 수열 h0, h1, ...  을 갭 수열이라고 합니다. 이 수열을 잡는 방법은 다양합니다. 31, 15, 7, 3, 1 과 같이 2^k - 1 로 잡거나 h1 = n/7 로 잡고 hi = h(i-1)/5 -1 처럼 h 가 5보다 큰 동안 삽입 정렬을 수행한 다음 마지막으로 전체 배열에 대해 삽입정렬을 합니다. **셸 정렬은 앞의 준비 단계에 소모한 시간이 얼마나 작으냐에 달려 있습니다.** 아래는 15개의 원소를 가진 배열을 7, 3, 1 의 간격으로 정렬하는 예시입니다.

![image-20230523164923328](../../images/2023-09-28-[자료구조알고리즘] 인터뷰 - 자료구조 및 알고리즘/image-20230523164923328.png)

먼저 7칸씩 떨어진 원소들끼리 삽입정렬을 하고, 3칸씩 떨어진 원소들끼리 삽입정렬을 합니다. 마지막으로 전체 배열에 대해 삽입 정렬을 실시합니다.

```
shellSort(A[]):
	for h <- h0, h2, ..., 1 //갭 수열
		for k <- 0 to h-1
			stepInsertionSort(A, k, h)

stepInsertionSort(A[], k, h):
	for(i <- k+h; i <= n-1; i <- i+h)
		insertionItem <- A[i]
		for(j <- i - h; 0 <= j and isertionItem < A[j]; j <- j-h)
			A[j+h] <- A[j]
        A[j+h] <- insertionItem
```

```java
public void shellSort(){
    for(int h = A.length / 7; h > 5; h = h/5 - 1){
        for(int k = 0; k <= h - 1; k++){
            stepInsertionSort(k, h); //k 는 시작 인덱스, h 는 간격
        }
    }
    stepInsertionSort(0, 1); //마지막으로 삽입정렬
}

private void stepInsertionSort(int k, int h){ 
    int j, insItem;
    for(int i = k + h; i <= A.length - 1; i += h){
        insItem = A[i];
        for(j = i - h; j >= 0 && A[i] > insItem; j -= h){
            A[j + h] = A[j];
        }
        A[j + h] = insItem;
    }
}
```



![image-20230928165122488](../../images/2023-09-28-[자료구조알고리즘] 인터뷰 - 자료구조 및 알고리즘/image-20230928165122488.png)
