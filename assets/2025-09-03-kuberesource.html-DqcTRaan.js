import{_ as o,c as u,a as e,b as t,d,f as a,r as i,o as p,e as l}from"./app-BfgOrurZ.js";const c="/images/2025-09-03-kuberesource/image-20250904205438084.png",g={},m={class:"table-of-contents"};function h(b,s){const r=i("Header"),n=i("router-link");return p(),u("div",null,[e(r),t("nav",m,[t("ul",null,[t("li",null,[e(n,{to:"#컨테이너와-파드-사용량-제한-limits-requests"},{default:a(()=>s[0]||(s[0]=[l("컨테이너와 파드 사용량 제한: Limits, requests")])),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#limits-와-requests"},{default:a(()=>s[1]||(s[1]=[l("Limits 와 Requests")])),_:1})]),t("li",null,[e(n,{to:"#qos-클래스"},{default:a(()=>s[2]||(s[2]=[l("QoS 클래스")])),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#guaranteed-클래스"},{default:a(()=>s[3]||(s[3]=[l("Guaranteed 클래스")])),_:1})]),t("li",null,[e(n,{to:"#besteffort-클래스"},{default:a(()=>s[4]||(s[4]=[l("BestEffort 클래스")])),_:1})]),t("li",null,[e(n,{to:"#burstable-클래스"},{default:a(()=>s[5]||(s[5]=[l("Burstable 클래스")])),_:1})]),t("li",null,[e(n,{to:"#안정적으로-b가-800mib까지-쓰게-하려면"},{default:a(()=>s[6]||(s[6]=[l("안정적으로 B가 800MiB까지 쓰게 하려면")])),_:1})]),t("li",null,[e(n,{to:"#축출"},{default:a(()=>s[7]||(s[7]=[l("축출")])),_:1})])])]),t("li",null,[e(n,{to:"#_1-요청-초과-여부로-1차-후보군을-가른다"},{default:a(()=>s[8]||(s[8]=[l("1) 요청 초과 여부로 1차 후보군을 가른다")])),_:1})]),t("li",null,[e(n,{to:"#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터"},{default:a(()=>s[9]||(s[9]=[l("2) 같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터")])),_:1})]),t("li",null,[e(n,{to:"#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터"},{default:a(()=>s[10]||(s[10]=[l("3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터")])),_:1}),t("ul",null,[t("li",null,[e(n,{to:"#추가-메모"},{default:a(()=>s[11]||(s[11]=[l("추가 메모")])),_:1})])])])])])])]),s[12]||(s[12]=d(`<p>쿠버네티스로 배포된 서버를 운영하기 위한 마지막 단계 중 하나는 실제 부하를 테스트해보는 것이다. 테스트를 하기 전에 우선 파드별로 할당된 리소스가 적절한지 확인하려고 했다. 그리고 테스트 이후에 다시 평가할 예정이다.</p><p>파드별로 cpu, memory 리소스가 필요한만큼 제대로 분배되지 못하면 노드의 리소스는 남음에도 파드의 리소스 제한으로 인해 남은 노드의 리소스를 모두 못쓰거나, 과도한 오버커밋때문에 중요한 파드가 꺼질 수도 있다.</p><h1 id="컨테이너와-파드-사용량-제한-limits-requests" tabindex="-1"><a class="header-anchor" href="#컨테이너와-파드-사용량-제한-limits-requests"><span>컨테이너와 파드 사용량 제한: Limits, requests</span></a></h1><h2 id="limits-와-requests" tabindex="-1"><a class="header-anchor" href="#limits-와-requests"><span>Limits 와 Requests</span></a></h2><p>쿠버네티스는 limits 키워드를 통해 자원 사용량의 최대치를 제한시키고, requests 로 자원의 최소치를 보장한다.</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">apiVerision</span><span class="token punctuation">:</span> v1</span>
<span class="line"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod</span>
<span class="line"><span class="token key atrule">metadata</span><span class="token punctuation">:</span></span>
<span class="line">	<span class="token key atrule">name</span><span class="token punctuation">:</span> limited<span class="token punctuation">-</span>pod</span>
<span class="line"><span class="token key atrule">spec</span><span class="token punctuation">:</span></span>
<span class="line">	<span class="token key atrule">containers</span><span class="token punctuation">:</span></span>
<span class="line">	<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx</span>
<span class="line">	  <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx</span>
<span class="line">	  <span class="token key atrule">resources</span><span class="token punctuation">:</span></span>
<span class="line">	    <span class="token key atrule">limits</span><span class="token punctuation">:</span></span>
<span class="line">	      <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 1000m</span>
<span class="line">	      <span class="token key atrule">memory</span><span class="token punctuation">:</span> 512MiB</span>
<span class="line">      <span class="token key atrule">requests</span><span class="token punctuation">:</span></span>
<span class="line">	      <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m</span>
<span class="line">	      <span class="token key atrule">memory</span><span class="token punctuation">:</span> 128MiB</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>쿠버네티스는 컨테이너의 자원활용률을 높이기 위해 <strong>오버커밋</strong>을 사용한다. 오버커밋이란 한정된 컴퓨팅 자원을 효율적으로 사용하기 위한 방법으로 사용할 수 있는 자원보다 더 많은 양을 VM 또는 컨테이너에게 할당하는 것이다.</p><p>예를 들어 아래처럼 메모리가 1GiB 인 노드에 각각 requests, limits 가 400MiB, 700MiB 인 컨테이너(파드)가 2개 있다고 가정하자.</p><p><img src="`+c+'" alt="image-20250904205438084"></p><p>물리적인 메모리는 1GiB 지만 A, B 각각에게 할당된 메모리의 합은 대략 <strong>1.4GiB</strong> 이다. 이처럼 유휴 자원이 남을 때 오버커밋을 통해 자원이 유동적으로 분배된다.</p><p>하지만 위와 같은 상황에서 A 컨테이너가 자신의 request 만큼 사용해야 한다면(자원의 경합) 어떤 일이 벌어질까?</p><h2 id="qos-클래스" tabindex="-1"><a class="header-anchor" href="#qos-클래스"><span>QoS 클래스</span></a></h2><p>메모리는 압축불가능한(Incompressible) 자원으로 취급되기 때문에 메모리 사용량에 경합이 발생하면 우선순위가 낮은 파드를 강제 종료시킨다.</p><p>여기서 중요한 부분은 **&#39;메모리 자원 부족 시 어떤 파드가 먼저 종료돼야 하는가&#39;**이다. 쿠버네티스는 Limits 와 Requests 값에 따라 우선순위를 정하는데 특히 3가지 종류의 QoS (Quality Of Service) 클래스가 파드별로 설정되어 활용된다.</p><blockquote><p>쿠버네티스의 파드 Eviction 과 노드의 oom_killer 의 동작은 다르다. 파드 Eviction 시 QoS 는 고려되지 않는다.</p></blockquote><h3 id="guaranteed-클래스" tabindex="-1"><a class="header-anchor" href="#guaranteed-클래스"><span>Guaranteed 클래스</span></a></h3><h3 id="besteffort-클래스" tabindex="-1"><a class="header-anchor" href="#besteffort-클래스"><span>BestEffort 클래스</span></a></h3><h3 id="burstable-클래스" tabindex="-1"><a class="header-anchor" href="#burstable-클래스"><span>Burstable 클래스</span></a></h3><p><strong>복잡성을 늘리지 말자</strong></p><p>observability 에는 ResourceQuota 을 할당하지 않음 -&gt; 노드가 늘어날 수록 생기는 daemonset 이 있기 떄문</p><hr><h3 id="안정적으로-b가-800mib까지-쓰게-하려면" tabindex="-1"><a class="header-anchor" href="#안정적으로-b가-800mib까지-쓰게-하려면"><span>안정적으로 B가 800MiB까지 쓰게 하려면</span></a></h3><ul><li>B를 <strong>Guaranteed QoS</strong>로: <code>requests.memory = limits.memory = 800MiB</code></li><li>또는 <strong>PriorityClass</strong>로 우선순위 부여(필요 시 preemption 허용)</li><li><strong>노드 용량 증설</strong>/전용 노드 배치(taint/toleration, nodeSelector)</li><li>네임스페이스에 <strong>ResourceQuota</strong>로 총합 가드, <strong>LimitRange</strong>로 기본값/상하한 정렬 (과도한 overcommit 방지)</li></ul><h3 id="축출" tabindex="-1"><a class="header-anchor" href="#축출"><span>축출</span></a></h3><ul><li>Burstable 내에서는 요청(request)을 얼마나 초과해서 쓰는지가 큰 파드부터 우선 퇴출됩니다. (usage − request가 큰 순)</li><li>Guaranteed는 가장 마지막에 퇴출 대상이지만, 노드가 심하게 부족하면 결국 퇴출될 수도 있습니다.</li><li>**컨테이너 한도 초과(OOMKilled)**는 별개입니다. 컨테이너가 자신의 limit을 넘으면 QoS와 무관하게 즉시 OOMKilled 됩니다.</li><li>PriorityClass가 설정돼 있으면, 우선 낮은 우선순위의 파드가 먼저 고려되고, 같은 우선순위끼리일 때 QoS 순서가 적용됩니다.</li></ul><p>좋아요. kubelet이 <strong>메모리 압박(eviction)</strong> 때 파드 축출 대상을 고를 때, 보통 아래 **우선 기준(순서)**로 판단합니다:</p><ol><li>“요청(request)을 초과해서 쓰는가?”</li><li>“파드 우선순위(PriorityClass)는 낮은가?”</li><li>“요청 대비 초과 사용량(usage − request)은 큰가?”</li></ol><p>각 단계마다 <strong>작동 예시</strong>를 들어볼게요. (단위는 메모리)</p><hr><h2 id="_1-요청-초과-여부로-1차-후보군을-가른다" tabindex="-1"><a class="header-anchor" href="#_1-요청-초과-여부로-1차-후보군을-가른다"><span>1) 요청 초과 여부로 1차 후보군을 가른다</span></a></h2><p>노드 용량: <strong>1 GiB</strong></p><table><thead><tr><th>Pod</th><th>QoS</th><th>request</th><th>사용량(usage)</th><th>비고</th></tr></thead><tbody><tr><td>A</td><td>Burstable</td><td>200Mi</td><td>150Mi</td><td><strong>요청 이하</strong></td></tr><tr><td>B</td><td>Burstable</td><td>300Mi</td><td>700Mi</td><td><strong>요청 초과 (+400Mi)</strong></td></tr><tr><td>C</td><td>BestEffort</td><td>0</td><td>80Mi</td><td><strong>요청 초과(+80Mi)</strong> ← request=0이면 사용&gt;0 즉시 초과로 간주</td></tr></tbody></table><ul><li>메모리 압박이 오면 kubelet은 **요청을 넘겨 쓰는 파드(B, C)**를 먼저 후보로 묶습니다.</li><li>요청 이하로 쓰는 A는 <strong>후순위</strong>(보통 마지막까지 남음).</li></ul><hr><h2 id="_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터" tabindex="-1"><a class="header-anchor" href="#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터"><span>2) 같은 “요청 초과” 그룹 안에서는 <strong>PriorityClass</strong>가 낮은 것부터</span></a></h2><p>위 표에서 B와 C가 후보라고 가정하고, 우선순위를 이렇게 둡니다:</p><table><thead><tr><th>Pod</th><th>PriorityClass</th><th>설명</th></tr></thead><tbody><tr><td>B</td><td>1000</td><td>일반 업무 파드</td></tr><tr><td>C</td><td>0</td><td>우선순위 미설정(기본)</td></tr></tbody></table><ul><li>두 파드 모두 “요청 초과”라면, **우선순위가 더 낮은 C(0)**가 <strong>먼저 축출 후보</strong>가 됩니다.</li><li>만약 C가 더 높은 우선순위(예: 10000)를 갖고, B가 낮다면 <strong>B가 먼저</strong> 나갑니다.</li></ul><blockquote><p>요약: 같은 그룹(요청 초과) 안에서는 <strong>낮은 Priority → 먼저 축출</strong>.</p></blockquote><hr><h2 id="_3-우선순위까지-같다면-usage-−-request-가-큰-것부터" tabindex="-1"><a class="header-anchor" href="#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터"><span>3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터</span></a></h2><p>두 파드의 Priority가 같다고 가정:</p><table><thead><tr><th>Pod</th><th>request</th><th>usage</th><th>usage − request</th></tr></thead><tbody><tr><td>B</td><td>300Mi</td><td>700Mi</td><td><strong>+400Mi</strong></td></tr><tr><td>C</td><td>0</td><td>80Mi</td><td><strong>+80Mi</strong></td></tr></tbody></table><ul><li>둘 다 요청 초과 + 동일 Priority라면, **초과량이 더 큰 B(+400Mi)**가 <strong>먼저 축출</strong> 후보가 됩니다.</li><li>이 때문에 상황에 따라 **BestEffort(C)**보다 **Burstable(B)**이 먼저 나가는 **‘역전’**이 실제로 발생할 수 있습니다. (BestEffort가 항상 먼저인 건 아님)</li></ul><hr><h3 id="추가-메모" tabindex="-1"><a class="header-anchor" href="#추가-메모"><span>추가 메모</span></a></h3><ul><li><strong>Guaranteed</strong>(request=limit)은 보통 <strong>가장 마지막</strong>에 축출됩니다.</li><li><strong>OS 레벨 OOM Killer</strong>가 개입하는 진짜 OOM 상황에서는 <code>oom_score_adj</code>(QoS/우선순위에 따라 다름)와 실제 사용량이 함께 작용해, <strong>많이 쓰는 컨테이너</strong>가 더 불리합니다.</li><li><strong>CPU 부족</strong>은 파드 축출 사유가 아니라 스로틀링으로 처리되는 점(주로 eviction은 메모리/디스크 압박)도 참고하세요.</li></ul><p><strong>정리:</strong> 우선순위가 낮아도 “요청 이하”이면 <em>덜 위험</em>할 뿐, <strong>상황이 심하면 축출될 수 있습니다.</strong> 진짜 보호가 필요하면 <code>requests≈피크 사용</code>으로 잡아 <strong>Guaranteed QoS</strong>에 가깝게 하고, 필요한 경우 <strong>PriorityClass</strong>와 전용 노드(taints/tolerations)까지 고려하세요.</p>',48))])}const f=o(g,[["render",h],["__file","2025-09-03-kuberesource.html.vue"]]),v=JSON.parse('{"path":"/posts/infra/2025-09-03-kuberesource.html","title":"쿠버네티스 운영 환경 준비 하기 - 파드 리소스 할당","lang":"en-US","frontmatter":{"title":"쿠버네티스 운영 환경 준비 하기 - 파드 리소스 할당","date":"2025-09-04T00:00:00.000Z","tags":["kubenetes","resources","pod"],"description":"파드 리소스 사용량 제한 확인하기"},"headers":[{"level":1,"title":"컨테이너와 파드 사용량 제한: Limits, requests","slug":"컨테이너와-파드-사용량-제한-limits-requests","link":"#컨테이너와-파드-사용량-제한-limits-requests","children":[{"level":2,"title":"Limits 와 Requests","slug":"limits-와-requests","link":"#limits-와-requests","children":[]},{"level":2,"title":"QoS 클래스","slug":"qos-클래스","link":"#qos-클래스","children":[{"level":3,"title":"Guaranteed 클래스","slug":"guaranteed-클래스","link":"#guaranteed-클래스","children":[]},{"level":3,"title":"BestEffort 클래스","slug":"besteffort-클래스","link":"#besteffort-클래스","children":[]},{"level":3,"title":"Burstable 클래스","slug":"burstable-클래스","link":"#burstable-클래스","children":[]},{"level":3,"title":"안정적으로 B가 800MiB까지 쓰게 하려면","slug":"안정적으로-b가-800mib까지-쓰게-하려면","link":"#안정적으로-b가-800mib까지-쓰게-하려면","children":[]},{"level":3,"title":"축출","slug":"축출","link":"#축출","children":[]}]},{"level":2,"title":"1) 요청 초과 여부로 1차 후보군을 가른다","slug":"_1-요청-초과-여부로-1차-후보군을-가른다","link":"#_1-요청-초과-여부로-1차-후보군을-가른다","children":[]},{"level":2,"title":"2) 같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터","slug":"_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터","link":"#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터","children":[]},{"level":2,"title":"3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터","slug":"_3-우선순위까지-같다면-usage-−-request-가-큰-것부터","link":"#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터","children":[{"level":3,"title":"추가 메모","slug":"추가-메모","link":"#추가-메모","children":[]}]}]}],"git":{},"filePathRelative":"_posts/infra/2025-09-03-kuberesource.md"}');export{f as comp,v as data};
