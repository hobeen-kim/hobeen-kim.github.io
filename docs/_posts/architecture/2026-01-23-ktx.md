---
title: "[아키텍처] KTX 예약 시스템 설계"
date: 2026-01-23
tags:
  - ktx
  - architecture
  - reservation
description: "ktx 예약 시스템을 설계해보자"
---
<Header />

[[toc]]

아키텍처 항목의 첫 포스트로 KTX 예약 시스템을 설계해보겠다. KTX 예약 시스템은 동시성을 관리하는 데에 있어서는 극한이라고 볼 수 있다. 명절 예매를 하기 위해 수백만 명의 접속이 동시에 몰리는데 하나의 오차도 없이 들어온 순서대로 좌석 선택과 예매를 진행해야 하기 때문이다.

## 1. 핵심 가치 및 기능

내가 생각하는 핵심가치는 다음과 같다.

- 모든 사용자는 예기치 않은 서버 오류없이 좌석 선택 - 예매 - 결제를 완료해야 한다.
- 먼저 들어온 사용자는 이후 사용자보다 먼저 좌석을 선택할 수 있어야 한다.

즉, **장애 대응**과 **순서 보장**이다.

### 1.1 기능

**예매 대기**

- 사용자 중 1만명은 예매 페이지로 진입할 수 있다.
- 나머지 사용자는 예매 대기 페이지에서 순서를 기다린다. 이때 예매 대기 페이지로 진입한 순서대로 예매 페이지로 진입한다.
- 예매 대기 페이지의 사용자는 자신의 순서와 총 대기자 수를 알 수 있다.
- 예매 대기 페이지의 사용자가 해당 페이지를 이탈하면 순서에서 빠진다. (재진입 시 제일 후순위로 진입한다.)

**예매**

- 사용자는 예매 페이지에서 호차와 좌석을 선택할 수 있다.
- 좌석을 선택하고 결제 버튼을 누르는 시점에 해당 좌석을 선점한다.
- 예매는 5분안에 완료되어야 한다. (시간 연장은 고려하지 않는다.)

**결제**

- 결제는 10분 안에 완료되어야 하며 결제되지 않으면 좌석인 비선점 상태로 복구된다.

### 1.2 규모 예측

(명절을 기준으로 한다.)

- 명절 열차는 당일의 D-28일 12시에 예매할 수 있다.
- 예매를 시도하려는 사람은 200만 명이며 100만명은 1분 이내에, 나머지 100만명은 10분 이내에 모두 접속한다.
- 접속 후 예매 및 결제 플로우는 다음과 같다.
  - 예매 페이지 접속 -> 호차 선택 -> 좌석 선택 -> 결제
  - 접속이 원활하다면 1분 정도 걸리는 플로우이다.
- 예매 대기 페이지에 1분 내에 100만 명이 동시에 접속한다면 평균적인 TPS 를 구하기 어려우나, 최대 100만 TPS 라고 가정한다.
- 예매 페이지는 최대 1만명이 사용할 수 있다. 1만 명이 1분 동안 5~6개의 API 를 호출하므로 TPS 는 10,000 x 6 / 60 = 1000TPS 이다.

## 2. 간단한 설계

## 3. 상세한 설계

### 3.1 reids
- 멱등성
- 순위 구하기

#### vs kafka : 멱등성 유지 x, 순위 구하기 x

#### 장애 처리
RDB vs AOF
- RDB 스냅샷: 주기 저장(빠르지만 최근 데이터 일부 손실 가능)
- AOF: 로그로 기록(더 복구 정확하지만 성능/용량 비용)

“큐/대기열(ZSET) 작업”의 중복/유실
- Redis Streams + Consumer Group (pending/재처리/ACK 지원) -> at-least-once + 멱등처리

####  sse, websocket vs polling

1) 연결 유지 비용(가장 큼)

SSE/웹소켓은 기본적으로 클라이언트당 장시간 연결을 유지해.

200만 동접이면 200만 개 연결을 서버(또는 LB)가 계속 들고 있어야 함

파일 디스크립터, 메모리, 커널 네트워크 버퍼, keep-alive, TLS 세션 등 비용이 큼

L4/L7 로드밸런서/프록시의 연결 한계에 빨리 닿음

폴링은 연결을 “짧게” 쓰고 끊기니, 인프라가 훨씬 다루기 쉬움.

2) 장애/재연결 폭탄(운영 리스크)

SSE/웹소켓은 네트워크가 흔들리면

동시에 재연결 스톰(reconnect storm)이 터지기 쉽고,

그게 대기 서버에 큰 부하를 줌

폴링은 원래 “주기적 요청”이라 재연결 스톰의 형태가 덜하고,
서버가 429로 간격 조절(백오프) 유도하기도 쉬움.

4) “대기열”은 실시간성이 그렇게까지 필요 없음

대기 순번은 보통 1초 단위 실시간이 아니라

2~5초 갱신만 해도 UX가 충분히 납득돼.
이 정도는 폴링이 가장 단순하고 효과적


### RDB

#### 원자적 업데이트
UPDATE seats SET status='HELD', hold_by=?, hold_until=now()+interval '3 min' WHERE seat_id=? AND (status='AVAILABLE' OR (status='HELD' AND hold_until < now()))

## 4. 구현

## 5. 참고 자료

- https://www.youtube.com/watch?v=c-ERjEodn_o



<Footer />