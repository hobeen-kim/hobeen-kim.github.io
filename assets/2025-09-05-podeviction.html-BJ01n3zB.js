import{_ as n,c as a,a as r,b as e,d as u,f as l,r as i,o as g,e as o}from"./app-DrhwENuX.js";const h={},p={class:"table-of-contents"};function c(_,t){const d=i("Header"),s=i("router-link");return g(),a("div",null,[r(d),e("nav",p,[e("ul",null,[e("li",null,[r(s,{to:"#축출"},{default:l(()=>t[0]||(t[0]=[o("축출")])),_:1})]),e("li",null,[r(s,{to:"#_1-요청-초과-여부로-1차-후보군을-가른다"},{default:l(()=>t[1]||(t[1]=[o("1) 요청 초과 여부로 1차 후보군을 가른다")])),_:1})]),e("li",null,[r(s,{to:"#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터"},{default:l(()=>t[2]||(t[2]=[o("2) 같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터")])),_:1})]),e("li",null,[r(s,{to:"#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터"},{default:l(()=>t[3]||(t[3]=[o("3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터")])),_:1}),e("ul",null,[e("li",null,[r(s,{to:"#추가-메모"},{default:l(()=>t[4]||(t[4]=[o("추가 메모")])),_:1})])])])])]),t[5]||(t[5]=u('<h3 id="축출" tabindex="-1"><a class="header-anchor" href="#축출"><span>축출</span></a></h3><ul><li>Burstable 내에서는 요청(request)을 얼마나 초과해서 쓰는지가 큰 파드부터 우선 퇴출됩니다. (usage − request가 큰 순)</li><li>Guaranteed는 가장 마지막에 퇴출 대상이지만, 노드가 심하게 부족하면 결국 퇴출될 수도 있습니다.</li><li>**컨테이너 한도 초과(OOMKilled)**는 별개입니다. 컨테이너가 자신의 limit을 넘으면 QoS와 무관하게 즉시 OOMKilled 됩니다.</li><li>PriorityClass가 설정돼 있으면, 우선 낮은 우선순위의 파드가 먼저 고려되고, 같은 우선순위끼리일 때 QoS 순서가 적용됩니다.</li></ul><p>좋아요. kubelet이 <strong>메모리 압박(eviction)</strong> 때 파드 축출 대상을 고를 때, 보통 아래 **우선 기준(순서)**로 판단합니다:</p><ol><li>“요청(request)을 초과해서 쓰는가?”</li><li>“파드 우선순위(PriorityClass)는 낮은가?”</li><li>“요청 대비 초과 사용량(usage − request)은 큰가?”</li></ol><p>각 단계마다 <strong>작동 예시</strong>를 들어볼게요. (단위는 메모리)</p><hr><h2 id="_1-요청-초과-여부로-1차-후보군을-가른다" tabindex="-1"><a class="header-anchor" href="#_1-요청-초과-여부로-1차-후보군을-가른다"><span>1) 요청 초과 여부로 1차 후보군을 가른다</span></a></h2><p>노드 용량: <strong>1 GiB</strong></p><table><thead><tr><th>Pod</th><th>QoS</th><th>request</th><th>사용량(usage)</th><th>비고</th></tr></thead><tbody><tr><td>A</td><td>Burstable</td><td>200Mi</td><td>150Mi</td><td><strong>요청 이하</strong></td></tr><tr><td>B</td><td>Burstable</td><td>300Mi</td><td>700Mi</td><td><strong>요청 초과 (+400Mi)</strong></td></tr><tr><td>C</td><td>BestEffort</td><td>0</td><td>80Mi</td><td><strong>요청 초과(+80Mi)</strong> ← request=0이면 사용&gt;0 즉시 초과로 간주</td></tr></tbody></table><ul><li>메모리 압박이 오면 kubelet은 **요청을 넘겨 쓰는 파드(B, C)**를 먼저 후보로 묶습니다.</li><li>요청 이하로 쓰는 A는 <strong>후순위</strong>(보통 마지막까지 남음).</li></ul><hr><h2 id="_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터" tabindex="-1"><a class="header-anchor" href="#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터"><span>2) 같은 “요청 초과” 그룹 안에서는 <strong>PriorityClass</strong>가 낮은 것부터</span></a></h2><p>위 표에서 B와 C가 후보라고 가정하고, 우선순위를 이렇게 둡니다:</p><table><thead><tr><th>Pod</th><th>PriorityClass</th><th>설명</th></tr></thead><tbody><tr><td>B</td><td>1000</td><td>일반 업무 파드</td></tr><tr><td>C</td><td>0</td><td>우선순위 미설정(기본)</td></tr></tbody></table><ul><li>두 파드 모두 “요청 초과”라면, **우선순위가 더 낮은 C(0)**가 <strong>먼저 축출 후보</strong>가 됩니다.</li><li>만약 C가 더 높은 우선순위(예: 10000)를 갖고, B가 낮다면 <strong>B가 먼저</strong> 나갑니다.</li></ul><blockquote><p>요약: 같은 그룹(요청 초과) 안에서는 <strong>낮은 Priority → 먼저 축출</strong>.</p></blockquote><hr><h2 id="_3-우선순위까지-같다면-usage-−-request-가-큰-것부터" tabindex="-1"><a class="header-anchor" href="#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터"><span>3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터</span></a></h2><p>두 파드의 Priority가 같다고 가정:</p><table><thead><tr><th>Pod</th><th>request</th><th>usage</th><th>usage − request</th></tr></thead><tbody><tr><td>B</td><td>300Mi</td><td>700Mi</td><td><strong>+400Mi</strong></td></tr><tr><td>C</td><td>0</td><td>80Mi</td><td><strong>+80Mi</strong></td></tr></tbody></table><ul><li>둘 다 요청 초과 + 동일 Priority라면, **초과량이 더 큰 B(+400Mi)**가 <strong>먼저 축출</strong> 후보가 됩니다.</li><li>이 때문에 상황에 따라 **BestEffort(C)**보다 **Burstable(B)**이 먼저 나가는 **‘역전’**이 실제로 발생할 수 있습니다. (BestEffort가 항상 먼저인 건 아님)</li></ul><hr><h3 id="추가-메모" tabindex="-1"><a class="header-anchor" href="#추가-메모"><span>추가 메모</span></a></h3><ul><li><strong>Guaranteed</strong>(request=limit)은 보통 <strong>가장 마지막</strong>에 축출됩니다.</li><li><strong>OS 레벨 OOM Killer</strong>가 개입하는 진짜 OOM 상황에서는 <code>oom_score_adj</code>(QoS/우선순위에 따라 다름)와 실제 사용량이 함께 작용해, <strong>많이 쓰는 컨테이너</strong>가 더 불리합니다.</li><li><strong>CPU 부족</strong>은 파드 축출 사유가 아니라 스로틀링으로 처리되는 점(주로 eviction은 메모리/디스크 압박)도 참고하세요.</li></ul><p><strong>정리:</strong> 우선순위가 낮아도 “요청 이하”이면 <em>덜 위험</em>할 뿐, <strong>상황이 심하면 축출될 수 있습니다.</strong> 진짜 보호가 필요하면 <code>requests≈피크 사용</code>으로 잡아 <strong>Guaranteed QoS</strong>에 가깝게 하고, 필요한 경우 <strong>PriorityClass</strong>와 전용 노드(taints/tolerations)까지 고려하세요.</p>',25))])}const f=n(h,[["render",c],["__file","2025-09-05-podeviction.html.vue"]]),m=JSON.parse('{"path":"/posts/tech/2025-09-05-podeviction.html","title":"쿠버네티스에서 리소스 경합에 의한 Eviction 과 oom_killer 차이","lang":"en-US","frontmatter":{"title":"쿠버네티스에서 리소스 경합에 의한 Eviction 과 oom_killer 차이","date":"2025-09-05T00:00:00.000Z","tags":["kubenetes","eviction","oom_killer"],"description":"두 파드 간에 메모리 등 리소스가 경합할 때 어떤 파드가 어떻게 꺼지고 축출되는지 알아보자"},"headers":[{"level":3,"title":"축출","slug":"축출","link":"#축출","children":[]},{"level":2,"title":"1) 요청 초과 여부로 1차 후보군을 가른다","slug":"_1-요청-초과-여부로-1차-후보군을-가른다","link":"#_1-요청-초과-여부로-1차-후보군을-가른다","children":[]},{"level":2,"title":"2) 같은 “요청 초과” 그룹 안에서는 PriorityClass가 낮은 것부터","slug":"_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터","link":"#_2-같은-요청-초과-그룹-안에서는-priorityclass가-낮은-것부터","children":[]},{"level":2,"title":"3) 우선순위까지 같다면, **(usage − request)**가 큰 것부터","slug":"_3-우선순위까지-같다면-usage-−-request-가-큰-것부터","link":"#_3-우선순위까지-같다면-usage-−-request-가-큰-것부터","children":[{"level":3,"title":"추가 메모","slug":"추가-메모","link":"#추가-메모","children":[]}]}],"git":{},"filePathRelative":"_posts/tech/2025-09-05-podeviction.md"}');export{f as comp,m as data};
