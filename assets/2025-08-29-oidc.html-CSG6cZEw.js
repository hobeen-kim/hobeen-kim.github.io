import{_ as d,c,a as t,b as o,d as u,f as n,r as a,o as h,e as l}from"./app-dXp5MBUq.js";const p="/images/2025-08-29-oidc/image-20250829154224561.png",g="/images/2025-08-29-oidc/image-20250829163419630.png",A={},C={class:"table-of-contents"};function v(O,e){const r=a("Header"),i=a("router-link"),s=a("Footer");return h(),c("div",null,[t(r),o("nav",C,[o("ul",null,[o("li",null,[t(i,{to:"#oauth-2-0-이란"},{default:n(()=>e[0]||(e[0]=[l("OAuth 2.0 이란?")])),_:1}),o("ul",null,[o("li",null,[t(i,{to:"#oauth-2-0-의-구성-요소"},{default:n(()=>e[1]||(e[1]=[l("OAuth 2.0 의 구성 요소")])),_:1})]),o("li",null,[t(i,{to:"#oauth-2-0-인증-grant-플로우"},{default:n(()=>e[2]||(e[2]=[l("OAuth 2.0 인증(Grant) (플로우)")])),_:1}),o("ul",null,[o("li",null,[t(i,{to:"#권한-코드-인증-authorization-code-pkce-권장"},{default:n(()=>e[3]||(e[3]=[l("권한 코드 인증 (Authorization Code, PKCE 권장)")])),_:1})]),o("li",null,[t(i,{to:"#클라이언트-자격-증명-인증"},{default:n(()=>e[4]||(e[4]=[l("클라이언트 자격 증명 인증")])),_:1})])])]),o("li",null,[t(i,{to:"#oauth-한계"},{default:n(()=>e[5]||(e[5]=[l("OAuth 한계")])),_:1})])])]),o("li",null,[t(i,{to:"#oidc"},{default:n(()=>e[6]||(e[6]=[l("OIDC")])),_:1}),o("ul",null,[o("li",null,[t(i,{to:"#비교-oauth-2-0-vs-oidc"},{default:n(()=>e[7]||(e[7]=[l("비교: OAuth 2.0 vs OIDC")])),_:1})]),o("li",null,[t(i,{to:"#oidc-용어"},{default:n(()=>e[8]||(e[8]=[l("OIDC 용어")])),_:1})]),o("li",null,[t(i,{to:"#oidc-흐름-권장-authorization-code-pkce"},{default:n(()=>e[9]||(e[9]=[l("OIDC 흐름 (권장: Authorization Code + PKCE)")])),_:1})])])]),o("li",null,[t(i,{to:"#ref"},{default:n(()=>e[10]||(e[10]=[l("Ref.")])),_:1})])])]),e[11]||(e[11]=u('<h1 id="oauth-2-0-이란" tabindex="-1"><a class="header-anchor" href="#oauth-2-0-이란"><span>OAuth 2.0 이란?</span></a></h1><p>OAuth 란 타 서비스의 자원(Resource) 에 접근 권한을, 비밀번호 공유 없이 제3의 애플리케이션(클라이언트)에게 위임하는 표준이다. 애플리케이션이 사용자 프로필이나 데이터와 같은 다른 애플리케이션의 보호된 리소스에 대해 비밀번호와 같은 자격 증명을 노출하지 않고도 안전하게 제한된 접근 권한을 얻을 수 있도록 한다.</p><h2 id="oauth-2-0-의-구성-요소" tabindex="-1"><a class="header-anchor" href="#oauth-2-0-의-구성-요소"><span>OAuth 2.0 의 구성 요소</span></a></h2><ul><li><strong>Resource Owner</strong>: 사용자(권한의 소유자).</li><li><strong>Client</strong>: 사용자의 허락을 받아 자원에 접근하려는 앱(웹/모바일/서버).</li><li><strong>Authorization Server (AS)</strong>: 권한을 승인하고 <strong>Access Token/Refresh Token</strong> 발급(Keycloak, Google 등).</li><li><strong>Resource Server (RS)</strong>: 보호 자원을 가진 API 서버(예: Google Drive API). 접근 토큰을 검증하고 클라이언트에게 보호된 리소스를 제공</li></ul><h2 id="oauth-2-0-인증-grant-플로우" tabindex="-1"><a class="header-anchor" href="#oauth-2-0-인증-grant-플로우"><span>OAuth 2.0 인증(Grant) (플로우)</span></a></h2><p>기본 OAuth 2.0 명세는 네 가지 인증을 정의합니다:</p><ul><li>권한 코드 인증 (Authorization Code)</li><li>암묵적 인증 (Implicit Flow)</li><li>리소스 소유자 비밀번호 자격 증명 (ROPC) 인증</li><li>클라이언트 자격 증명 인증 (Client Credentials)</li></ul><p>이중 암묵적 인증, ROPC 는 사용을 지양한다.</p><ul><li>암묵적 인증 : 브라우저로 <strong>토큰을 바로 전달</strong>하던 옛 방식. URL에 토큰이 노출되고, 토큰 탈취 위험이 커서 현대 권고안에선 사용하지 않음.</li><li>ROPC : 클라이언트가 <strong>사용자 ID/비밀번호를 직접 받는</strong> 방식. 보안·거버넌스 측면에서 최악의 선택지</li></ul><h3 id="권한-코드-인증-authorization-code-pkce-권장" tabindex="-1"><a class="header-anchor" href="#권한-코드-인증-authorization-code-pkce-권장"><span>권한 코드 인증 (Authorization Code, <strong>PKCE 권장</strong>)</span></a></h3><p>가장 표준적이고 안전해서 현재 기본값처럼 쓰는 흐름이다.</p><p><img src="'+p+`" alt="image-20250829154224561"></p><ol><li>리소스 소유자의 접근</li><li>클라이언트는 리소스 소유자에게 인증을 요청하고 해당 인증서버로 리다이렉션한다. (요청 : <code>response_type=code</code>, <code>state</code>, <strong><code>code_challenge</code></strong>)</li><li>리소스 소유자는 자신을 인증하고 권한을 부여한다.</li><li>클라이언트의 Redirect URI로 authorization code 를 전달한다.</li><li>클라이언트가 백채널로 authorization code + <code>code_verifier</code>를 인증 서버로 보내면 Access Token(+Refresh Token) 이 발급된다.</li><li>Access Token 을 사용하여 리소스를 요청한다..</li></ol><blockquote><p><strong>PKCE(Proof Key for Code Exchange)</strong> 란?</p><p>OAuth 2.0 <strong>Authorization Code Flow를 더 안전하게 만드는 보안 메커니즘</strong>이다.</p><ol><li>사용자가 로그인 → Authorization Server가 Authorization Code를 발급해서 브라우저(redirect URI)로 보냄.</li><li>앱(클라이언트)이 이 코드를 Authorization Server에 다시 보내면서 Access Token을 받음.</li></ol><p>만약 공격자가 여기서 중간에서 이 Authorization Code를 탈취당해면 원래 앱이 아니라 공격자가 Authorization Server에 code를 제출해서 Access Token을 뺏을 수 있다. 이걸 Authorization Code Interception Attack이라고 한다.</p><p>PKCE의 아이디어는 코드 교환 시 비밀값을 추가로 검증**하는 것이다.</p><ol><li><p>클라이언트가 로그인 요청을 보낼 때, 임의의 난수 문자열을 하나 만든다. → <strong>code_verifier</strong></p></li><li><p>이 값을 해시(SHA-256) 해서 → <strong>code_challenge</strong>를 만든다.</p></li><li><p>로그인 요청 시 Authorization Server에 <strong>code_challenge</strong>를 같이 보낸다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">GET /authorize?</span>
<span class="line">response_type=code</span>
<span class="line">&amp;client_id=client123</span>
<span class="line">&amp;redirect_uri=https://app.com/callback</span>
<span class="line">&amp;code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM</span>
<span class="line">&amp;code_challenge_method=S256</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Authorization Server는 이 challenge를 기억해둔다.</p></li><li><p>클라이언트가 Authorization Code를 Access Token으로 교환할 때, 원래 난수(<strong>code_verifier</strong>)를 같이 보낸다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">POST /token</span>
<span class="line">code=abc123</span>
<span class="line">code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Authorization Server는 이걸 해시해서 기존의 <code>code_challenge</code>와 비교 → 일치하면 토큰 발급.</p></li></ol><p>따라서, 공격자가 Authorization Code를 가로채도 <strong>code_verifier</strong>가 없으면 Access Token으로 교환할 수 없다.</p></blockquote><h3 id="클라이언트-자격-증명-인증" tabindex="-1"><a class="header-anchor" href="#클라이언트-자격-증명-인증"><span>클라이언트 자격 증명 인증</span></a></h3><p>클라이언트 자격 증명은 기밀 클라이언트가 보호된 리소스에 접근할 수 있도록 액세스 토큰을 받을 수 있는 OAuth 2.0 인증 부여 (Grant) 유형이다. 일반적으로 이 흐름은 클라이언트가 서버나 서비스인 기계 대 기계 (Machine-to-machine) 통신에 사용된다.</p><blockquote><p><strong>기계 대 기계 통신</strong></p><p>단일 서비스만 있고 그 무엇에도 의존하지 않는 경우 다른 서비스와 통신할 필요가 없을 가능성이 높다. 시스템이 성장하거나 아이덴티티 및 접근 관리(IAM) 시스템과 통합하려고 할 때, 기계 대 기계 통신을 처리해야 한다.</p></blockquote><p>클라이언트 자격 증명 흐름은 두 단계로 이루어진 간단한 프로세스다.</p><ol><li><strong>토큰 요청</strong>: 클라이언트는 토큰 요청 (Token request) 와 클라이언트 자격 증명 (클라이언트 ID 및 클라이언트 비밀), 요청된 scopes (스코프)와 함께 보낸다.</li><li><strong>토큰 응답</strong>: 인증 서버 (Authorization server) 는 클라이언트 자격 증명을 검증하고 클라이언트가 인증되었다면 액세스 토큰을 발행한다.</li></ol><h2 id="oauth-한계" tabindex="-1"><a class="header-anchor" href="#oauth-한계"><span>OAuth 한계</span></a></h2><ul><li>OAuth 는 접근 권한에 초점을 맞추기 때문에 인증(누구인지) 을 보장하지 않는다.</li><li>Access Token이 불투명 문자열이면 리소스 서버는 매번 Introspection(인증 서버에 확인)해야 사용자·스코프를 알 수 있어 네트워크 왕복이 늘어난다.</li><li>토큰에 어떤 속성이 담기는지 표준화가 느슨해서, &quot;사용자 식별&quot; 용도로 일관되게 쓰기 어렵다</li></ul><h1 id="oidc" tabindex="-1"><a class="header-anchor" href="#oidc"><span>OIDC</span></a></h1><p>OpenID Connect 는 OAuth 2.0을 인증(Authentication) 용도로 확장한 표준이다. 가장 큰 추가점은 ID Token(JWT) 이고, 여기에 사용자 식별 정보(Claims) 가 담긴다.</p><ul><li><strong>ID Token</strong>: <code>iss</code>, <code>sub</code>, <code>aud</code>, <code>exp</code>, <code>iat</code> + (선택) <code>email</code>, <code>name</code>, <code>auth_time</code>, <code>nonce</code>, <code>at_hash</code> 등.</li><li><strong>UserInfo Endpoint</strong>: Access Token으로 추가 프로필 정보를 표준 스키마로 조회. 클라이언트가 사용자 프로필 정보를 검색할 수 있는 OIDC 전용 엔드포인트이다</li><li><strong>Discovery</strong>: <code>/.well-known/openid-configuration</code>로 OP(인증서버) 메타데이터 자동 발견.</li><li><strong>JWKs</strong>: 공개키 목록(URL)로 서명 검증 자동화.</li></ul><h3 id="비교-oauth-2-0-vs-oidc" tabindex="-1"><a class="header-anchor" href="#비교-oauth-2-0-vs-oidc"><span>비교: OAuth 2.0 vs OIDC</span></a></h3><p>OIDC와 OAuth 2.0의 관계는 그 목적을 이해해야 명확히 구분할 수 있다. 둘의 차이는 &#39;인증&#39;과 &#39;인가&#39;라는 근본적인 개념의 차이에서 비롯된다.</p><blockquote><p><strong>&quot;OAuth 2.0은 인가(Authorization), OIDC는 인증(Authentication)&quot;</strong></p></blockquote><p>**OAuth 2.0 (인가)**는 &quot;이 애플리케이션이 <strong>무엇을 할 수 있는가?</strong>&quot;이다. 예를 들어, 한 사진 편집 앱이 사용자의 구글 포토에 접근하여 사진을 읽고 편집할 권한을 요청한다. 사용자가 동의하면, 구글은 이 앱에게 액세스 토큰을 발급한다. 이 토큰은 앱이 구글 포토 API에 접근할 수 있는 &#39;열쇠&#39; 역할을 하지만, 토큰 자체에는 사용자가 누구인지에 대한 정보가 표준화된 방식으로 담겨있지 않다. 앱은 단지 &#39;권한을 위임받았다&#39;는 사실만 알 뿐이다.</p><p>**OIDC (인증)**의 핵심 질문은 &quot;이 사용자는 <strong>누구인가?</strong>&quot;이다. 예를 들어, 새로운 뉴스레터 서비스에 &#39;구글 계정으로 로그인&#39;하는 경우를 생각해 보면 이 과정에서 OIDC가 사용된다. 사용자가 구글에서 인증을 완료하면, 구글은 뉴스레터 서비스에게 액세스 토큰과 함께 &#39;ID Token&#39;을 전달한다. 이 ID Token에는 사용자의 이메일, 이름, 고유 식별자 등이 포함되어 있어, 뉴스레터 서비스는 이 정보를 바탕으로 사용자를 식별하고 회원 가입을 처리하거나 로그인 세션을 생성할 수 있다.</p><p>결론적으로, OIDC는 OAuth 2.0의 인가 흐름을 그대로 사용하면서, 그 위에 &#39;;사용자 신원 확인&#39;이라는 표준화된 계층을 추가한 것이다. 따라서 모든 OIDC 흐름은 OAuth 2.0 흐름이기도 하지만, 그 역은 성립하지 않는다.</p><h2 id="oidc-용어" tabindex="-1"><a class="header-anchor" href="#oidc-용어"><span>OIDC 용어</span></a></h2><ul><li><strong>OP (OpenID Provider)</strong>: 인증 서버(예: Keycloak, Google)</li><li><strong>RP (Relying Party)</strong>: OP를 신뢰하고 토큰을 검증하는 클라이언트 앱</li><li><strong>ID Token</strong>: 인증 결과(사용자 ID 등)가 담긴 JWT. 사용자를 대신하여 보호된 리소스에 접근하는 데 사용</li><li><strong>Nonce</strong>: 재생 공격 방지용 랜덤 값(클라이언트가 보냈던 값과 토큰의 <code>nonce</code> 일치 확인)</li><li><strong>Scope</strong>: 최소 <code>openid</code> 가 필수. 그 외 <code>profile</code>, <code>email</code>, <code>phone</code>, <code>address</code> 등</li><li><strong>Claims</strong>: 토큰에 담기는 속성들(표준 + 커스텀)</li></ul><h2 id="oidc-흐름-권장-authorization-code-pkce" tabindex="-1"><a class="header-anchor" href="#oidc-흐름-권장-authorization-code-pkce"><span>OIDC 흐름 (권장: <strong>Authorization Code + PKCE</strong>)</span></a></h2><p><img src="`+g+'" alt="image-20250829163419630"></p><h1 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>Ref.</span></a></h1><ul><li><a href="https://auth-wiki.logto.io/ko/openid-connect" target="_blank" rel="noopener noreferrer">OpenID Connect (OIDC)은(는) 무엇인가요?</a></li><li><a href="https://auth-wiki.logto.io/ko/oauth-2.0" target="_blank" rel="noopener noreferrer">OAuth 2.0은(는) 무엇인가요?</a></li><li><a href="https://aodtns.tistory.com/124" target="_blank" rel="noopener noreferrer">Open ID Connect 으로 구글 로그인 구현하기 (feat. SpringBoot)</a></li><li><a href="https://s-core.co.kr/insight/view/%ED%8E%B8%EC%9D%98%EC%84%B1%EC%9D%84-%EB%86%92%EC%9D%B8-id-%EC%9D%B8%EC%A6%9D-%EA%B4%80%EB%A6%AC-oidc%EA%B0%80-%EC%A3%BC%EB%AA%A9-%EB%B0%9B%EB%8A%94-%EC%9D%B4%EC%9C%A0/" target="_blank" rel="noopener noreferrer">편의성을 높인 ID 인증 관리: OIDC가 주목 받는 이유</a></li></ul>',36)),t(s)])}const f=d(A,[["render",v],["__file","2025-08-29-oidc.html.vue"]]),m=JSON.parse('{"path":"/posts/tech/2025-08-29-oidc.html","title":"OAuth 와 비교한 OIDC 개념 알아보기","lang":"en-US","frontmatter":{"title":"OAuth 와 비교한 OIDC 개념 알아보기","date":"2025-08-29T00:00:00.000Z","tags":["oauth","idc"],"description":"OIDC 가 뭔지 궁금해서 찾아봤습니다."},"headers":[{"level":1,"title":"OAuth 2.0 이란?","slug":"oauth-2-0-이란","link":"#oauth-2-0-이란","children":[{"level":2,"title":"OAuth 2.0 의 구성 요소","slug":"oauth-2-0-의-구성-요소","link":"#oauth-2-0-의-구성-요소","children":[]},{"level":2,"title":"OAuth 2.0 인증(Grant) (플로우)","slug":"oauth-2-0-인증-grant-플로우","link":"#oauth-2-0-인증-grant-플로우","children":[{"level":3,"title":"권한 코드 인증 (Authorization Code, PKCE 권장)","slug":"권한-코드-인증-authorization-code-pkce-권장","link":"#권한-코드-인증-authorization-code-pkce-권장","children":[]},{"level":3,"title":"클라이언트 자격 증명 인증","slug":"클라이언트-자격-증명-인증","link":"#클라이언트-자격-증명-인증","children":[]}]},{"level":2,"title":"OAuth 한계","slug":"oauth-한계","link":"#oauth-한계","children":[]}]},{"level":1,"title":"OIDC","slug":"oidc","link":"#oidc","children":[{"level":3,"title":"비교: OAuth 2.0 vs OIDC","slug":"비교-oauth-2-0-vs-oidc","link":"#비교-oauth-2-0-vs-oidc","children":[]},{"level":2,"title":"OIDC 용어","slug":"oidc-용어","link":"#oidc-용어","children":[]},{"level":2,"title":"OIDC 흐름 (권장: Authorization Code + PKCE)","slug":"oidc-흐름-권장-authorization-code-pkce","link":"#oidc-흐름-권장-authorization-code-pkce","children":[]}]},{"level":1,"title":"Ref.","slug":"ref","link":"#ref","children":[]}],"git":{},"filePathRelative":"_posts/tech/2025-08-29-oidc.md"}');export{f as comp,m as data};
