import{_ as c,a as r,b as u}from"./image-20250802153517306-B8z-jszq.js";import{_ as d,c as k,a,b as s,d as v,f as e,r as o,o as b,e as p}from"./app-BdGmrpQV.js";const m={},g={class:"table-of-contents"};function f(S,n){const l=o("Header"),t=o("router-link"),i=o("Footer");return b(),k("div",null,[a(l),s("nav",g,[s("ul",null,[s("li",null,[a(t,{to:"#_1-문제-상황-실시간-색상-전파가-필요하다"},{default:e(()=>n[0]||(n[0]=[p("1. 문제 상황: 실시간 색상 전파가 필요하다!")])),_:1})]),s("li",null,[a(t,{to:"#_2-websocket-vs-sse"},{default:e(()=>n[1]||(n[1]=[p("2. WebSocket vs SSE")])),_:1}),s("ul",null,[s("li",null,[a(t,{to:"#websocket-강력한-양방향-소통"},{default:e(()=>n[2]||(n[2]=[p("WebSocket: 강력한 양방향 소통")])),_:1})]),s("li",null,[a(t,{to:"#sse-효율적인-단방향-알림"},{default:e(()=>n[3]||(n[3]=[p("SSE: 효율적인 단방향 알림")])),_:1})]),s("li",null,[a(t,{to:"#한눈에-보는-비교와-선택의-기로"},{default:e(()=>n[4]||(n[4]=[p("한눈에 보는 비교와 선택의 기로")])),_:1})])])]),s("li",null,[a(t,{to:"#_3-코드로-확인하기"},{default:e(()=>n[5]||(n[5]=[p("3. 코드로 확인하기")])),_:1}),s("ul",null,[s("li",null,[a(t,{to:"#notification-도메인-구성"},{default:e(()=>n[6]||(n[6]=[p("Notification 도메인 구성")])),_:1})])])]),s("li",null,[a(t,{to:"#_4-나의-서버를-위한-최종-선택과-결론"},{default:e(()=>n[7]||(n[7]=[p("4. 나의 서버를 위한 최종 선택과 결론")])),_:1})])])]),n[8]||(n[8]=v('<p>토이 프로젝트를 하면서 서버로부터 데이터를 받아와야하는 구간이 있었다. 그 부분을 해결하기 위해 서칭하면서 &#39;실시간&#39;하면 무조건 떠올리던 WebSocket 이 항상 최선은 아닐 수 있다는 인사이트를 얻었다.</p><h1 id="_1-문제-상황-실시간-색상-전파가-필요하다" tabindex="-1"><a class="header-anchor" href="#_1-문제-상황-실시간-색상-전파가-필요하다"><span>1. 문제 상황: 실시간 색상 전파가 필요하다!</span></a></h1><p>내가 만들던 애플리케이션은 레딧의 만우절 이벤트 r/place 에서 착안한 간단한 협업 도구였다.</p><p><img src="'+c+'" alt="image-20250802150658605"></p><p>수많은 점(dot)으로 이루어진 거대한 그리드가 있고, 사용자들은 각 점의 색을 바꿔 하나의 그림을 완성해나가는 서비스였다. 핵심 기능은 명확했다.</p><blockquote><p>한 유저가 특정 점의 색깔을 바꾸면, 그 정보가 다른 모든 접속자에게 실시간으로 전파되어야 한다.</p></blockquote><p>이 요구사항을 듣자마자 머릿속에 떠오른 단어는 단연 &#39;웹소켓(WebSocket)&#39;이었다. 실시간, 양방향 통신이라는 키워드에 이보다 더 적합한 기술은 없어 보였기 때문이다. 당연하게도 나는 WebSocket을 적용하는 방향으로 초기 설계를 시작했다.</p><h1 id="_2-websocket-vs-sse" tabindex="-1"><a class="header-anchor" href="#_2-websocket-vs-sse"><span>2. WebSocket vs SSE</span></a></h1><p>설계를 구체화하던 중, 문득 한 가지 의문이 들었다. &quot;과연 우리에게 양방향 통신이 꼭 필요한가?&quot; 사용자가 색을 바꾸는 행위(클라이언트 → 서버)는 단발적인 HTTP POST 요청으로도 충분히 처리할 수 있다. 정작 실시간성이 필요한 부분은 서버가 &quot;색이 바뀌었어!&quot;라고 모든 클라이언트에게 알려주는, 즉 서버 → 클라이언트 방향의 통신이었다. 이 고민은 나를 Server-Sent Events(SSE)라는 또 다른 선택지로 이끌었다.</p><h2 id="websocket-강력한-양방향-소통" tabindex="-1"><a class="header-anchor" href="#websocket-강력한-양방향-소통"><span>WebSocket: 강력한 양방향 소통</span></a></h2><p>웹소켓은 클라이언트와 서버 간에 하나의 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. <a href="https://yuricoding.tistory.com/134" target="_blank" rel="noopener noreferrer">2014년 HTML5 표준의 일부로 채택</a>된 이후, 실시간 채팅, 멀티플레이어 게임, 협업 편집 툴 등 즉각적인 상호작용이 필수적인 서비스의 기반 기술로 자리 잡았다. 한번 연결이 수립되면 클라이언트든 서버든 언제든지 데이터를 보낼 수 있는 강력한 양방향성이 가장 큰 특징이다.</p><p><img src="'+r+'" alt="image-20250802153529019"></p><ul><li><strong>프로토콜:</strong> <code>ws://</code> 또는 <code>wss://</code> 라는 별도의 프로토콜을 사용한다.</li><li><strong>통신 방식:</strong> 양방향(Bi-directional). 서버와 클라이언트가 동등하게 데이터를 주고받을 수 있다.</li><li><strong>주요 특징:</strong> 낮은 지연 시간, 높은 성능. 텍스트뿐만 아니라 바이너리 데이터 전송도 가능하다.</li></ul><h2 id="sse-효율적인-단방향-알림" tabindex="-1"><a class="header-anchor" href="#sse-효율적인-단방향-알림"><span>SSE: 효율적인 단방향 알림</span></a></h2><p>Server-Sent Events(SSE)는 이름 그대로 서버가 클라이언트에게 이벤트를 보내는 기술이다. 일반적인 HTTP 프로토콜을 기반으로 동작하며, 서버에서 클라이언트로의 단방향 데이터 스트리밍을 위해 설계되었다. 클라이언트는 <code>EventSource</code> 인터페이스를 통해 서버의 특정 엔드포인트를 &#39;구독&#39;하고, 서버는 이 연결을 유지하며 필요할 때마다 데이터를 &#39;푸시&#39;한다.</p><p><img src="'+u+`" alt="image-20250802153517306"></p><ul><li><strong>프로토콜:</strong> 표준 HTTP/HTTPS를 사용한다.</li><li><strong>통신 방식:</strong> 단방향(Uni-directional). 서버에서 클라이언트로만 데이터를 보낼 수 있다.</li><li><strong>주요 특징:</strong> 구현이 비교적 간단하고, 기존 인프라와 호환성이 좋다. 연결이 끊겼을 때 <a href="https://surviveasdev.tistory.com/entry/%EC%9B%B9%EC%86%8C%EC%BC%93-%EA%B3%BC-SSEServer-Sent-Event-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0" target="_blank" rel="noopener noreferrer">브라우저가 자동으로 재연결을 시도</a>하는 편리한 기능이 내장되어 있다.</li></ul><h2 id="한눈에-보는-비교와-선택의-기로" tabindex="-1"><a class="header-anchor" href="#한눈에-보는-비교와-선택의-기로"><span>한눈에 보는 비교와 선택의 기로</span></a></h2><p>두 기술의 차이점을 명확히 인지하자, 프로젝트에 대한 해답이 보이기 시작했다.</p><table><thead><tr><th style="text-align:left;">구분</th><th style="text-align:left;">WebSocket</th><th style="text-align:left;">SSE (Server-Sent Events)</th></tr></thead><tbody><tr><td style="text-align:left;">통신 방향</td><td style="text-align:left;">양방향 (Full-duplex)</td><td style="text-align:left;">단방향 (Server → Client)</td></tr><tr><td style="text-align:left;">프로토콜</td><td style="text-align:left;">WebSocket (ws/wss)</td><td style="text-align:left;">HTTP/HTTPS</td></tr><tr><td style="text-align:left;">자동 재연결</td><td style="text-align:left;">기본적으로 미지원 (라이브러리 필요)</td><td style="text-align:left;">브라우저가 자동 지원</td></tr><tr><td style="text-align:left;">데이터 형식</td><td style="text-align:left;">UTF-8, 바이너리</td><td style="text-align:left;">UTF-8 텍스트만 가능</td></tr><tr><td style="text-align:left;">주요 사용 사례</td><td style="text-align:left;">채팅, 온라인 게임, 협업 툴</td><td style="text-align:left;">알림, 실시간 뉴스 피드, 주식 시세</td></tr></tbody></table><p>프로젝트에서는 서버가 클라이언트에게 일방적으로 업데이트를 알리기만 하면 충분했다. 클라이언트가 서버로 무언가를 계속 보낼 필요가 없었다. 이 경우, 양방향 통신을 위한 웹소켓은 다소 과한 스펙(Over-spec)이었다. 반면 SSE는 가볍고, 구현이 간단하며, 우리의 요구사항에 정확히 부합했다. 따라서 나는 초기 계획을 수정하여 SSE를 도입하기로 결정했다.</p><h1 id="_3-코드로-확인하기" tabindex="-1"><a class="header-anchor" href="#_3-코드로-확인하기"><span>3. 코드로 확인하기</span></a></h1><p>이번에는 Spring WebFlux 기반의 SSE가 실제로 어떻게 구현되는지 코드를 통해 확인해보자. 나는 이 문제를 해결하기 위해 Notification 이라는 별도의 도메인으로 분리하여 설계하였으며, 이를 통해 <strong>관심사의 분리</strong>와 <strong>확장성</strong>을 확보했다.</p><h2 id="notification-도메인-구성" tabindex="-1"><a class="header-anchor" href="#notification-도메인-구성"><span>Notification 도메인 구성</span></a></h2><p>알림(Notification)은 특정 방(room)에 속한 클라이언트에게 이벤트를 전달하는 역할을 담당한다. SSE를 통해 서버에서 클라이언트로 푸시되는 이벤트의 공통 추상화를 위해 <code>NotificationMessage</code>라는 추상 클래스를 기반으로 설계되었다.</p><p><strong>NotificationMessage.kt</strong></p><p>알림 메시지의 공통적인 형태를 정의하는 추상 클래스다. 모든 알림은 특정 room(방)으로 전송되므로 <code>room</code> 필드를 공통 인터페이스로 정의했다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">abstract</span> <span class="token keyword">class</span> NotificationMessage <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">abstract</span> <span class="token keyword">val</span> room<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SolveNotificationMessage.kt</strong></p><p>점의 색을 바꾸기 위한 이벤트다. 사용자가 특정 좌표의 점(dot)을 특정 색으로 바꾸는 행위에 대한 알림을 전송할 때 사용된다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">SolveNotificationMessage</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">val</span> col<span class="token operator">:</span> Int<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">val</span> row<span class="token operator">:</span> Int<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">override</span> <span class="token keyword">val</span> room<span class="token operator">:</span> String<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">val</span> color<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">NotificationMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>NotificationEventListener.kt</strong></p><p>Spring의 <code>@EventListener</code>를 활용하여 애플리케이션 이벤트를 수신하는 컴포넌트다. 도메인 내에서 <code>NotificationMessage</code>가 발행되면, 이를 받아 <code>NotificationSink</code>에 전달하여 구독자에게 전송되도록 한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@Component</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token function">NotificationEventListener</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> notificationSink<span class="token operator">:</span> NotificationSink</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation builtin">@EventListener</span></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">handle</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SolveNotificationMessage<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        notificationSink<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>NotificationSink.kt</strong></p><p>실제 메시지를 전송하는 핵심 컴포넌트이다. 각 room마다 고유한 <code>Sink</code>를 생성하여, 해당 방의 구독자들에게만 메시지를 전파한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@Component</span></span>
<span class="line"><span class="token keyword">class</span> NotificationSink <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> sinkMap<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Sinks<span class="token punctuation">.</span>Many<span class="token operator">&lt;</span>NotificationMessage<span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">emit</span><span class="token punctuation">(</span>message<span class="token operator">:</span> NotificationMessage<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> sink <span class="token operator">=</span> sinkMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            Sinks<span class="token punctuation">.</span><span class="token function">many</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onBackpressureBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        sink<span class="token punctuation">.</span><span class="token function">tryEmitNext</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">asFlux</span><span class="token punctuation">(</span>room<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Flux<span class="token operator">&lt;</span>NotificationMessage<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> sink <span class="token operator">=</span> sinkMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            Sinks<span class="token punctuation">.</span><span class="token function">many</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onBackpressureBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> sink<span class="token punctuation">.</span><span class="token function">asFlux</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>주요 동작</strong></p><ul><li><code>computeIfAbsent</code>: 방이 존재하지 않으면 새로운 <code>Sink</code>를 생성</li><li><code>Sinks.many().multicast()</code>: 여러 구독자가 동일한 메시지를 받을 수 있도록 설정</li><li><code>onBackpressureBuffer()</code>: 수신자가 느릴 경우 버퍼링 처리</li></ul><blockquote><p><code>roomId</code> 기준으로 메시지 흐름을 분리함으로써, 구독자는 본인이 속한 방의 이벤트만 수신하게 됨</p></blockquote><p><strong>SseController.kt</strong></p><p>클라이언트가 <code>/api/notifications/subscribe/{room}</code> 엔드포인트를 통해 SSE 구독을 시작하는 진입점이다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@RestController</span></span>
<span class="line"><span class="token annotation builtin">@RequestMapping</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;/api/notifications&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token function">SseController</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> notificationSink<span class="token operator">:</span> NotificationSink</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation builtin">@GetMapping</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;/subscribe/{room}&quot;</span></span><span class="token punctuation">,</span> produces <span class="token operator">=</span> <span class="token punctuation">[</span>MediaType<span class="token punctuation">.</span>TEXT_EVENT_STREAM_VALUE<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token annotation builtin">@PathVariable</span> room<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Flux<span class="token operator">&lt;</span>ServerSentEvent<span class="token operator">&lt;</span>NotificationMessage<span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> notificationSink<span class="token punctuation">.</span><span class="token function">asFlux</span><span class="token punctuation">(</span>room<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> message <span class="token operator">-&gt;</span></span>
<span class="line">                ServerSentEvent<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>주요 특징</strong></p><ul><li><code>Flux&lt;ServerSentEvent&lt;...&gt;&gt;</code>를 리턴함으로써 스트리밍 형태의 응답을 구성</li><li><code>TEXT_EVENT_STREAM_VALUE</code>는 SSE 전용 Media Type</li><li>구독한 클라이언트는 서버로부터 지속적으로 이벤트를 수신</li></ul><p>SSE 예시 코드에서 볼 수 있듯, 클라이언트의 색상 변경 요청은 일반적인 <code>POST</code> 요청으로 처리하고, 서버는 이 요청을 받은 뒤 연결된 모든 SSE 클라이언트에게 <code>gridUpdate</code> 이벤트를 전송한다. 이는 우리 프로젝트의 요구사항과 정확히 일치하는 흐름이다.</p><h1 id="_4-나의-서버를-위한-최종-선택과-결론" tabindex="-1"><a class="header-anchor" href="#_4-나의-서버를-위한-최종-선택과-결론"><span>4. 나의 서버를 위한 최종 선택과 결론</span></a></h1><p>결론적으로, 프로젝트에서는 SSE를 채택했다. 이 선택의 핵심 이유는 &#39;<strong>필요한 만큼의 기술</strong>&#39;을 사용하는 것이 가장 효율적이라는 판단 때문이었다. WebSocket의 강력한 양방향성은 매력적이지만, 우리에게는 서버에서 클라이언트로의 단방향 푸시만으로 충분했다. SSE는 더 가볍고, 구현이 간단하며, 자동 재연결과 같은 편의 기능까지 제공한다.</p><p>모든 &#39;실시간&#39; 기능에 WebSocket을 기계적으로 적용하기보다, 데이터 흐름의 방향성을 먼저 분석하는 것이 중요하다. 서버가 일방적으로 데이터를 밀어주는 상황이 대부분이라면, SSE는 더 우아하고 경제적인 해결책이 될 수 있다. 기술의 &#39;유행&#39;이나 &#39;인지도&#39;가 아닌, &#39;본질적인 필요&#39;에 집중할 때 비로소 최적의 아키텍처를 설계할 수 있다는 것을 다시 한번 깨닫게 된 소중한 경험이었다.</p>`,49)),a(i)])}const E=d(m,[["render",f],["__file","2025-07-20-ssewebsocket.html.vue"]]),w=JSON.parse('{"path":"/posts/tech/2025-07-20-ssewebsocket.html","title":"WebSocket 과 SSE","lang":"en-US","frontmatter":{"title":"WebSocket 과 SSE","date":"2025-07-20T00:00:00.000Z","tags":["websocket","sse"],"description":"실시간 통신, WebSocket이 항상 정답일까? SSE와 비교하며 최적의 기술 찾기"},"headers":[{"level":1,"title":"1. 문제 상황: 실시간 색상 전파가 필요하다!","slug":"_1-문제-상황-실시간-색상-전파가-필요하다","link":"#_1-문제-상황-실시간-색상-전파가-필요하다","children":[]},{"level":1,"title":"2. WebSocket vs SSE","slug":"_2-websocket-vs-sse","link":"#_2-websocket-vs-sse","children":[{"level":2,"title":"WebSocket: 강력한 양방향 소통","slug":"websocket-강력한-양방향-소통","link":"#websocket-강력한-양방향-소통","children":[]},{"level":2,"title":"SSE: 효율적인 단방향 알림","slug":"sse-효율적인-단방향-알림","link":"#sse-효율적인-단방향-알림","children":[]},{"level":2,"title":"한눈에 보는 비교와 선택의 기로","slug":"한눈에-보는-비교와-선택의-기로","link":"#한눈에-보는-비교와-선택의-기로","children":[]}]},{"level":1,"title":"3. 코드로 확인하기","slug":"_3-코드로-확인하기","link":"#_3-코드로-확인하기","children":[{"level":2,"title":"Notification 도메인 구성","slug":"notification-도메인-구성","link":"#notification-도메인-구성","children":[]}]},{"level":1,"title":"4. 나의 서버를 위한 최종 선택과 결론","slug":"_4-나의-서버를-위한-최종-선택과-결론","link":"#_4-나의-서버를-위한-최종-선택과-결론","children":[]}],"git":{},"filePathRelative":"_posts/tech/2025-07-20-ssewebsocket.md"}');export{E as comp,w as data};
