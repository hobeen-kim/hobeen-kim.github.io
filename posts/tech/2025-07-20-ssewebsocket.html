<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>WebSocket 과 SSE | 앤디  블로그 (블로그 공사중)🚧</title><meta name="description" content="실시간 통신, WebSocket이 항상 정답일까? SSE와 비교하며 최적의 기술 찾기">
    <link rel="preload" href="/assets/style-DzLoKC0N.css" as="style"><link rel="stylesheet" href="/assets/style-DzLoKC0N.css">
    <link rel="modulepreload" href="/assets/app-Dlj71d5o.js"><link rel="modulepreload" href="/assets/2025-07-20-ssewebsocket.html-IWIxttPq.js">
    <link rel="prefetch" href="/assets/index.html-DfWoHQ9M.js" as="script"><link rel="prefetch" href="/assets/index.html-BQriR01d.js" as="script"><link rel="prefetch" href="/assets/index.html-By8KgHVP.js" as="script"><link rel="prefetch" href="/assets/index.html-DnYDPwe_.js" as="script"><link rel="prefetch" href="/assets/2025-02-08-whatiswork.html-D-vjnWKY.js" as="script"><link rel="prefetch" href="/assets/2025-02-11-kafka.html-B8NlSCQV.js" as="script"><link rel="prefetch" href="/assets/2025-02-16-object.html-mu0WI5v7.js" as="script"><link rel="prefetch" href="/assets/2025-03-03-skilloflove.html-DLjDNg5_.js" as="script"><link rel="prefetch" href="/assets/2025-03-08-terraform.html-BoeNkuO2.js" as="script"><link rel="prefetch" href="/assets/2025-03-09-software.html-DVK_Jw1A.js" as="script"><link rel="prefetch" href="/assets/2025-03-23-chosun.html-D2PpL9cg.js" as="script"><link rel="prefetch" href="/assets/2025-02-07-ze.html-BR6vcyOf.js" as="script"><link rel="prefetch" href="/assets/2025-02-10-firstlog.html-kxZvHraV.js" as="script"><link rel="prefetch" href="/assets/2025-02-14-log.html-CA3BnIIu.js" as="script"><link rel="prefetch" href="/assets/2025-02-23-anna.html-4asTj2HI.js" as="script"><link rel="prefetch" href="/assets/2025-03-02-bystander.html-DJLm7hLS.js" as="script"><link rel="prefetch" href="/assets/2025-04-08-k8s.html-Ct8iUyxK.js" as="script"><link rel="prefetch" href="/assets/2025-04-20-log.html-CPjBnqnN.js" as="script"><link rel="prefetch" href="/assets/2025-03-15-filesystem.html-mNZCmL7K.js" as="script"><link rel="prefetch" href="/assets/2025-05-04-awsregion.html-BE7YyBF9.js" as="script"><link rel="prefetch" href="/assets/2025-06-27-iot.html-CKMxrP3Z.js" as="script"><link rel="prefetch" href="/assets/index.html-Kv2uaMhq.js" as="script"><link rel="prefetch" href="/assets/2025-02-25-aws.html-Dcok8Ado.js" as="script"><link rel="prefetch" href="/assets/2025-03-13-aws.html-_Q4In94Q.js" as="script"><link rel="prefetch" href="/assets/2025-03-20-aws.html-CyiW9go9.js" as="script"><link rel="prefetch" href="/assets/index.html-PkMJo2Ap.js" as="script"><link rel="prefetch" href="/assets/2025-08-26-culture1.html-2AEjRSrT.js" as="script"><link rel="prefetch" href="/assets/index.html-kdulQzCa.js" as="script"><link rel="prefetch" href="/assets/2025-04-20-leteraljoin.html-BU3CG_pE.js" as="script"><link rel="prefetch" href="/assets/index.html-Be0NAcYr.js" as="script"><link rel="prefetch" href="/assets/2025-02-03-post.html-CrnB6RFQ.js" as="script"><link rel="prefetch" href="/assets/index.html-BgsUqdBK.js" as="script"><link rel="prefetch" href="/assets/2025-02-13-security.html-CwP3E55s.js" as="script"><link rel="prefetch" href="/assets/2025-06-25-alarm.html-CFreoWyB.js" as="script"><link rel="prefetch" href="/assets/2025-08-05-test1.html-B42Oqofn.js" as="script"><link rel="prefetch" href="/assets/2025-08-20-test2.html-CgRizJIT.js" as="script"><link rel="prefetch" href="/assets/index.html-f5zjTVtX.js" as="script"><link rel="prefetch" href="/assets/2025-08-13-mqtt.html-Di-Xbwa5.js" as="script"><link rel="prefetch" href="/assets/index.html-DrM8qPBd.js" as="script"><link rel="prefetch" href="/assets/404.html-Cz-Ccehh.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-7MC2TMWH-Bethx6yJ.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">앤디  블로그 (블로그 공사중)🚧</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="글"><span class="title">글</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="글"><span class="title">글</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/posts/" aria-label="모두"><!--[--><!--[--><!--]--><!--]-->모두<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/culture/" aria-label="개발 문화"><!--[--><!--[--><!--]--><!--]-->개발 문화<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/posts/tech/" aria-label="기술"><!--[--><!--[--><!--]--><!--]-->기술<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/kafka/" aria-label="카프카"><!--[--><!--[--><!--]--><!--]-->카프카<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/spring/" aria-label="스프링"><!--[--><!--[--><!--]--><!--]-->스프링<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/cloud/" aria-label="클라우드"><!--[--><!--[--><!--]--><!--]-->클라우드<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/database/" aria-label="데이터베이스"><!--[--><!--[--><!--]--><!--]-->데이터베이스<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/conference/" aria-label="컨퍼런스"><!--[--><!--[--><!--]--><!--]-->컨퍼런스<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/books/" aria-label="책"><!--[--><!--[--><!--]--><!--]-->책<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/logs/" aria-label="짧은 글"><!--[--><!--[--><!--]--><!--]-->짧은 글<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="글"><span class="title">글</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="글"><span class="title">글</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/posts/" aria-label="모두"><!--[--><!--[--><!--]--><!--]-->모두<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/culture/" aria-label="개발 문화"><!--[--><!--[--><!--]--><!--]-->개발 문화<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/posts/tech/" aria-label="기술"><!--[--><!--[--><!--]--><!--]-->기술<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/kafka/" aria-label="카프카"><!--[--><!--[--><!--]--><!--]-->카프카<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/spring/" aria-label="스프링"><!--[--><!--[--><!--]--><!--]-->스프링<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/cloud/" aria-label="클라우드"><!--[--><!--[--><!--]--><!--]-->클라우드<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/database/" aria-label="데이터베이스"><!--[--><!--[--><!--]--><!--]-->데이터베이스<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/posts/conference/" aria-label="컨퍼런스"><!--[--><!--[--><!--]--><!--]-->컨퍼런스<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/books/" aria-label="책"><!--[--><!--[--><!--]--><!--]-->책<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/logs/" aria-label="짧은 글"><!--[--><!--[--><!--]--><!--]-->짧은 글<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">WebSocket 과 SSE <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#_1-문제-상황-실시간-색상-전파가-필요하다" aria-label="1. 문제 상황: 실시간 색상 전파가 필요하다!"><!--[--><!--[--><!--]--><!--]-->1. 문제 상황: 실시간 색상 전파가 필요하다!<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#_2-websocket-vs-sse" aria-label="2. WebSocket vs SSE"><!--[--><!--[--><!--]--><!--]-->2. WebSocket vs SSE<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#websocket-강력한-양방향-소통" aria-label="WebSocket: 강력한 양방향 소통"><!--[--><!--[--><!--]--><!--]-->WebSocket: 강력한 양방향 소통<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#sse-효율적인-단방향-알림" aria-label="SSE: 효율적인 단방향 알림"><!--[--><!--[--><!--]--><!--]-->SSE: 효율적인 단방향 알림<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#한눈에-보는-비교와-선택의-기로" aria-label="한눈에 보는 비교와 선택의 기로"><!--[--><!--[--><!--]--><!--]-->한눈에 보는 비교와 선택의 기로<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#_3-코드로-확인하기" aria-label="3. 코드로 확인하기"><!--[--><!--[--><!--]--><!--]-->3. 코드로 확인하기<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#notification-도메인-구성" aria-label="Notification 도메인 구성"><!--[--><!--[--><!--]--><!--]-->Notification 도메인 구성<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#_4-나의-서버를-위한-최종-선택과-결론" aria-label="4. 나의 서버를 위한 최종 선택과 결론"><!--[--><!--[--><!--]--><!--]-->4. 나의 서버를 위한 최종 선택과 결론<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><header class="page-header" data-v-84f05ea1><h1 class="title" data-v-84f05ea1>WebSocket 과 SSE</h1><div class="meta" data-v-84f05ea1><time data-v-84f05ea1>2025년 7월 20일</time></div></header><nav class="table-of-contents"><ul><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#_1-문제-상황-실시간-색상-전파가-필요하다" class="router-link-active router-link-exact-active">1. 문제 상황: 실시간 색상 전파가 필요하다!</a></li><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#_2-websocket-vs-sse" class="router-link-active router-link-exact-active">2. WebSocket vs SSE</a><ul><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#websocket-강력한-양방향-소통" class="router-link-active router-link-exact-active">WebSocket: 강력한 양방향 소통</a></li><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#sse-효율적인-단방향-알림" class="router-link-active router-link-exact-active">SSE: 효율적인 단방향 알림</a></li><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#한눈에-보는-비교와-선택의-기로" class="router-link-active router-link-exact-active">한눈에 보는 비교와 선택의 기로</a></li></ul></li><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#_3-코드로-확인하기" class="router-link-active router-link-exact-active">3. 코드로 확인하기</a><ul><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#notification-도메인-구성" class="router-link-active router-link-exact-active">Notification 도메인 구성</a></li></ul></li><li><a aria-current="page" href="/posts/tech/2025-07-20-ssewebsocket.html#_4-나의-서버를-위한-최종-선택과-결론" class="router-link-active router-link-exact-active">4. 나의 서버를 위한 최종 선택과 결론</a></li></ul></nav><p>토이 프로젝트를 하면서 서버로부터 데이터를 받아와야하는 구간이 있었다. 그 부분을 해결하기 위해 서칭하면서 &#39;실시간&#39;하면 무조건 떠올리던 WebSocket 이 항상 최선은 아닐 수 있다는 인사이트를 얻었다.</p><h1 id="_1-문제-상황-실시간-색상-전파가-필요하다" tabindex="-1"><a class="header-anchor" href="#_1-문제-상황-실시간-색상-전파가-필요하다"><span>1. 문제 상황: 실시간 색상 전파가 필요하다!</span></a></h1><p>내가 만들던 애플리케이션은 레딧의 만우절 이벤트 r/place 에서 착안한 간단한 협업 도구였다.</p><p><img src="/images/2025-07-20-ssewebsocket/image-20250802150658605.png" alt="image-20250802150658605"></p><p>수많은 점(dot)으로 이루어진 거대한 그리드가 있고, 사용자들은 각 점의 색을 바꿔 하나의 그림을 완성해나가는 서비스였다. 핵심 기능은 명확했다.</p><blockquote><p>한 유저가 특정 점의 색깔을 바꾸면, 그 정보가 다른 모든 접속자에게 실시간으로 전파되어야 한다.</p></blockquote><p>이 요구사항을 듣자마자 머릿속에 떠오른 단어는 단연 &#39;웹소켓(WebSocket)&#39;이었다. 실시간, 양방향 통신이라는 키워드에 이보다 더 적합한 기술은 없어 보였기 때문이다. 당연하게도 나는 WebSocket을 적용하는 방향으로 초기 설계를 시작했다.</p><h1 id="_2-websocket-vs-sse" tabindex="-1"><a class="header-anchor" href="#_2-websocket-vs-sse"><span>2. WebSocket vs SSE</span></a></h1><p>설계를 구체화하던 중, 문득 한 가지 의문이 들었다. &quot;과연 우리에게 양방향 통신이 꼭 필요한가?&quot; 사용자가 색을 바꾸는 행위(클라이언트 → 서버)는 단발적인 HTTP POST 요청으로도 충분히 처리할 수 있다. 정작 실시간성이 필요한 부분은 서버가 &quot;색이 바뀌었어!&quot;라고 모든 클라이언트에게 알려주는, 즉 서버 → 클라이언트 방향의 통신이었다. 이 고민은 나를 Server-Sent Events(SSE)라는 또 다른 선택지로 이끌었다.</p><h2 id="websocket-강력한-양방향-소통" tabindex="-1"><a class="header-anchor" href="#websocket-강력한-양방향-소통"><span>WebSocket: 강력한 양방향 소통</span></a></h2><p>웹소켓은 클라이언트와 서버 간에 하나의 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. <a href="https://yuricoding.tistory.com/134" target="_blank" rel="noopener noreferrer">2014년 HTML5 표준의 일부로 채택</a>된 이후, 실시간 채팅, 멀티플레이어 게임, 협업 편집 툴 등 즉각적인 상호작용이 필수적인 서비스의 기반 기술로 자리 잡았다. 한번 연결이 수립되면 클라이언트든 서버든 언제든지 데이터를 보낼 수 있는 강력한 양방향성이 가장 큰 특징이다.</p><p><img src="/images/2025-07-20-ssewebsocket/image-20250802153529019.png" alt="image-20250802153529019"></p><ul><li><strong>프로토콜:</strong> <code>ws://</code> 또는 <code>wss://</code> 라는 별도의 프로토콜을 사용한다.</li><li><strong>통신 방식:</strong> 양방향(Bi-directional). 서버와 클라이언트가 동등하게 데이터를 주고받을 수 있다.</li><li><strong>주요 특징:</strong> 낮은 지연 시간, 높은 성능. 텍스트뿐만 아니라 바이너리 데이터 전송도 가능하다.</li></ul><h2 id="sse-효율적인-단방향-알림" tabindex="-1"><a class="header-anchor" href="#sse-효율적인-단방향-알림"><span>SSE: 효율적인 단방향 알림</span></a></h2><p>Server-Sent Events(SSE)는 이름 그대로 서버가 클라이언트에게 이벤트를 보내는 기술이다. 일반적인 HTTP 프로토콜을 기반으로 동작하며, 서버에서 클라이언트로의 단방향 데이터 스트리밍을 위해 설계되었다. 클라이언트는 <code>EventSource</code> 인터페이스를 통해 서버의 특정 엔드포인트를 &#39;구독&#39;하고, 서버는 이 연결을 유지하며 필요할 때마다 데이터를 &#39;푸시&#39;한다.</p><p><img src="/images/2025-07-20-ssewebsocket/image-20250802153517306.png" alt="image-20250802153517306"></p><ul><li><strong>프로토콜:</strong> 표준 HTTP/HTTPS를 사용한다.</li><li><strong>통신 방식:</strong> 단방향(Uni-directional). 서버에서 클라이언트로만 데이터를 보낼 수 있다.</li><li><strong>주요 특징:</strong> 구현이 비교적 간단하고, 기존 인프라와 호환성이 좋다. 연결이 끊겼을 때 <a href="https://surviveasdev.tistory.com/entry/%EC%9B%B9%EC%86%8C%EC%BC%93-%EA%B3%BC-SSEServer-Sent-Event-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0" target="_blank" rel="noopener noreferrer">브라우저가 자동으로 재연결을 시도</a>하는 편리한 기능이 내장되어 있다.</li></ul><h2 id="한눈에-보는-비교와-선택의-기로" tabindex="-1"><a class="header-anchor" href="#한눈에-보는-비교와-선택의-기로"><span>한눈에 보는 비교와 선택의 기로</span></a></h2><p>두 기술의 차이점을 명확히 인지하자, 프로젝트에 대한 해답이 보이기 시작했다.</p><table><thead><tr><th style="text-align:left;">구분</th><th style="text-align:left;">WebSocket</th><th style="text-align:left;">SSE (Server-Sent Events)</th></tr></thead><tbody><tr><td style="text-align:left;">통신 방향</td><td style="text-align:left;">양방향 (Full-duplex)</td><td style="text-align:left;">단방향 (Server → Client)</td></tr><tr><td style="text-align:left;">프로토콜</td><td style="text-align:left;">WebSocket (ws/wss)</td><td style="text-align:left;">HTTP/HTTPS</td></tr><tr><td style="text-align:left;">자동 재연결</td><td style="text-align:left;">기본적으로 미지원 (라이브러리 필요)</td><td style="text-align:left;">브라우저가 자동 지원</td></tr><tr><td style="text-align:left;">데이터 형식</td><td style="text-align:left;">UTF-8, 바이너리</td><td style="text-align:left;">UTF-8 텍스트만 가능</td></tr><tr><td style="text-align:left;">주요 사용 사례</td><td style="text-align:left;">채팅, 온라인 게임, 협업 툴</td><td style="text-align:left;">알림, 실시간 뉴스 피드, 주식 시세</td></tr></tbody></table><p>프로젝트에서는 서버가 클라이언트에게 일방적으로 업데이트를 알리기만 하면 충분했다. 클라이언트가 서버로 무언가를 계속 보낼 필요가 없었다. 이 경우, 양방향 통신을 위한 웹소켓은 다소 과한 스펙(Over-spec)이었다. 반면 SSE는 가볍고, 구현이 간단하며, 우리의 요구사항에 정확히 부합했다. 따라서 나는 초기 계획을 수정하여 SSE를 도입하기로 결정했다.</p><h1 id="_3-코드로-확인하기" tabindex="-1"><a class="header-anchor" href="#_3-코드로-확인하기"><span>3. 코드로 확인하기</span></a></h1><p>이번에는 Spring WebFlux 기반의 SSE가 실제로 어떻게 구현되는지 코드를 통해 확인해보자. 나는 이 문제를 해결하기 위해 Notification 이라는 별도의 도메인으로 분리하여 설계하였으며, 이를 통해 <strong>관심사의 분리</strong>와 <strong>확장성</strong>을 확보했다.</p><h2 id="notification-도메인-구성" tabindex="-1"><a class="header-anchor" href="#notification-도메인-구성"><span>Notification 도메인 구성</span></a></h2><p>알림(Notification)은 특정 방(room)에 속한 클라이언트에게 이벤트를 전달하는 역할을 담당한다. SSE를 통해 서버에서 클라이언트로 푸시되는 이벤트의 공통 추상화를 위해 <code>NotificationMessage</code>라는 추상 클래스를 기반으로 설계되었다.</p><p><strong>NotificationMessage.kt</strong></p><p>알림 메시지의 공통적인 형태를 정의하는 추상 클래스다. 모든 알림은 특정 room(방)으로 전송되므로 <code>room</code> 필드를 공통 인터페이스로 정의했다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">abstract</span> <span class="token keyword">class</span> NotificationMessage <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">abstract</span> <span class="token keyword">val</span> room<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SolveNotificationMessage.kt</strong></p><p>점의 색을 바꾸기 위한 이벤트다. 사용자가 특정 좌표의 점(dot)을 특정 색으로 바꾸는 행위에 대한 알림을 전송할 때 사용된다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">SolveNotificationMessage</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">val</span> col<span class="token operator">:</span> Int<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">val</span> row<span class="token operator">:</span> Int<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">override</span> <span class="token keyword">val</span> room<span class="token operator">:</span> String<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">val</span> color<span class="token operator">:</span> String</span>
<span class="line"><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">NotificationMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>NotificationEventListener.kt</strong></p><p>Spring의 <code>@EventListener</code>를 활용하여 애플리케이션 이벤트를 수신하는 컴포넌트다. 도메인 내에서 <code>NotificationMessage</code>가 발행되면, 이를 받아 <code>NotificationSink</code>에 전달하여 구독자에게 전송되도록 한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@Component</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token function">NotificationEventListener</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> notificationSink<span class="token operator">:</span> NotificationSink</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation builtin">@EventListener</span></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">handle</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SolveNotificationMessage<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        notificationSink<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>NotificationSink.kt</strong></p><p>실제 메시지를 전송하는 핵심 컴포넌트이다. 각 room마다 고유한 <code>Sink</code>를 생성하여, 해당 방의 구독자들에게만 메시지를 전파한다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@Component</span></span>
<span class="line"><span class="token keyword">class</span> NotificationSink <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> sinkMap<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Sinks<span class="token punctuation">.</span>Many<span class="token operator">&lt;</span>NotificationMessage<span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">emit</span><span class="token punctuation">(</span>message<span class="token operator">:</span> NotificationMessage<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> sink <span class="token operator">=</span> sinkMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            Sinks<span class="token punctuation">.</span><span class="token function">many</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onBackpressureBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        sink<span class="token punctuation">.</span><span class="token function">tryEmitNext</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">asFlux</span><span class="token punctuation">(</span>room<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Flux<span class="token operator">&lt;</span>NotificationMessage<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> sink <span class="token operator">=</span> sinkMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            Sinks<span class="token punctuation">.</span><span class="token function">many</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onBackpressureBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> sink<span class="token punctuation">.</span><span class="token function">asFlux</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>주요 동작</strong></p><ul><li><code>computeIfAbsent</code>: 방이 존재하지 않으면 새로운 <code>Sink</code>를 생성</li><li><code>Sinks.many().multicast()</code>: 여러 구독자가 동일한 메시지를 받을 수 있도록 설정</li><li><code>onBackpressureBuffer()</code>: 수신자가 느릴 경우 버퍼링 처리</li></ul><blockquote><p><code>roomId</code> 기준으로 메시지 흐름을 분리함으로써, 구독자는 본인이 속한 방의 이벤트만 수신하게 됨</p></blockquote><p><strong>SseController.kt</strong></p><p>클라이언트가 <code>/api/notifications/subscribe/{room}</code> 엔드포인트를 통해 SSE 구독을 시작하는 진입점이다.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt" data-title="kt"><pre><code><span class="line"><span class="token annotation builtin">@RestController</span></span>
<span class="line"><span class="token annotation builtin">@RequestMapping</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;/api/notifications&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token function">SseController</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> notificationSink<span class="token operator">:</span> NotificationSink</span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation builtin">@GetMapping</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;/subscribe/{room}&quot;</span></span><span class="token punctuation">,</span> produces <span class="token operator">=</span> <span class="token punctuation">[</span>MediaType<span class="token punctuation">.</span>TEXT_EVENT_STREAM_VALUE<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token annotation builtin">@PathVariable</span> room<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Flux<span class="token operator">&lt;</span>ServerSentEvent<span class="token operator">&lt;</span>NotificationMessage<span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> notificationSink<span class="token punctuation">.</span><span class="token function">asFlux</span><span class="token punctuation">(</span>room<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> message <span class="token operator">-&gt;</span></span>
<span class="line">                ServerSentEvent<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>주요 특징</strong></p><ul><li><code>Flux&lt;ServerSentEvent&lt;...&gt;&gt;</code>를 리턴함으로써 스트리밍 형태의 응답을 구성</li><li><code>TEXT_EVENT_STREAM_VALUE</code>는 SSE 전용 Media Type</li><li>구독한 클라이언트는 서버로부터 지속적으로 이벤트를 수신</li></ul><p>SSE 예시 코드에서 볼 수 있듯, 클라이언트의 색상 변경 요청은 일반적인 <code>POST</code> 요청으로 처리하고, 서버는 이 요청을 받은 뒤 연결된 모든 SSE 클라이언트에게 <code>gridUpdate</code> 이벤트를 전송한다. 이는 우리 프로젝트의 요구사항과 정확히 일치하는 흐름이다.</p><h1 id="_4-나의-서버를-위한-최종-선택과-결론" tabindex="-1"><a class="header-anchor" href="#_4-나의-서버를-위한-최종-선택과-결론"><span>4. 나의 서버를 위한 최종 선택과 결론</span></a></h1><p>결론적으로, 프로젝트에서는 SSE를 채택했다. 이 선택의 핵심 이유는 &#39;<strong>필요한 만큼의 기술</strong>&#39;을 사용하는 것이 가장 효율적이라는 판단 때문이었다. WebSocket의 강력한 양방향성은 매력적이지만, 우리에게는 서버에서 클라이언트로의 단방향 푸시만으로 충분했다. SSE는 더 가볍고, 구현이 간단하며, 자동 재연결과 같은 편의 기능까지 제공한다.</p><p>모든 &#39;실시간&#39; 기능에 WebSocket을 기계적으로 적용하기보다, 데이터 흐름의 방향성을 먼저 분석하는 것이 중요하다. 서버가 일방적으로 데이터를 밀어주는 상황이 대부분이라면, SSE는 더 우아하고 경제적인 해결책이 될 수 있다. 기술의 &#39;유행&#39;이나 &#39;인지도&#39;가 아닌, &#39;본질적인 필요&#39;에 집중할 때 비로소 최적의 아키텍처를 설계할 수 있다는 것을 다시 한번 깨닫게 된 소중한 경험이었다.</p><nav class="vp-page-nav" aria-label="page navigation" data-v-63cabaa2><!----><!----></nav></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><!----><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Dlj71d5o.js" defer></script>
  </body>
</html>
